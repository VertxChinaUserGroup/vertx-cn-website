小论学习的目的，比如怎样学计算机语言
圆胖肿
经常会遇到初学者，问，该怎么学这个学那个，比如怎样学java，这是遇到最多的问题

其实学一门计算机语言，本质上跟学英语，没有太大的差别，比学英语还简单一点

学英语的时候，千万千万，不要急着去被背单词，很多人学英语，就是跟着老师，一遍又一遍念课文，然后回家，一遍又一遍地把课后那些单词背下来，这样做效果非常差，事倍功半，我也曾经这样学过英语，效果显然是不好的，每次考试，都在及格线边缘挣扎，但是我觉得，这不对啊，为啥会这样？后来我的老师告诉我，因为我学习英语的目的搞错了

学英语的目的，是为了交流，语法，单词，这都是为了交流服务的，所以学英语的时候，应该主动地编织自己的技能树，从最简单的，我想用英语跟人打招呼应该怎么说，然后进一步，我想表达我要做什么，该怎么说，以此类推，遇到不会的障碍，想办法克服它，因为思考过，就不容易忘记，而且要用的时候，往往就能找得到表达方式，用这种方式，就用了不到半年左右时间，英语突飞猛进，最后雅思overall 7，阅读8.5，没有拿到9分表示很不爽，轻松过线

学计算机语言也是一样的，我们为什么要学java？理由呢？好找工作不是一个很好的学习理由，应该看一看，java为什么会在这么多语言中survive下来，历史上有过无数的计算机语言，但是最终存活下来的，屈指可数，就那么几个，翻来覆去都很容易看懂，那我们不妨想想为什么会这样？

其实编程的目的无非三个：

让机器能够执行我们的命令，而且执行得越快越好
让别人看懂我们的代码，这个在公司里面意义特别大，协作是必需的
让自己能够用比较少的劳动来实现目的，说白了就是让自己懒
说到这里，就能回答我们为什么要学习java了，因为java协作最方便，所以java里面各种规则，都是为了让别人看懂我们的代码用的，理解了这个，我们再去看一些细节，就事半功倍了，所以当其他语言claim自己能比java少写代码或者是有更多语法糖的时候，这未必就是一件好事，java应该通过ide等工具自动生成代码来解决啰嗦的问题，而不是通过简写或者是不写，因为我们要让别人看懂我们的代码，这是我们的目的，但是学完了java是不是就不学了？其他还有那么多语言呢，肿么办？当然要多搞搞，不能受限于java，一般局限在一个或者几个计算机语言中的程序员会特别偏执，因为他不会其他的语言，就怕你也会，就怕你用了他看不懂的计算机语言，而且不允许你说这些语言的不足，否则如丧考妣

好了，那该如何学习其他语言？或者是所有语言？那我们知道，编程语言有一个东西叫做paradigm，编程范式，计算机语言基本上是根据编程范式来区分的，同一种编程范式的计算机语言，会被归为一类，那编程范式也有很多种，那我们如果从以上三个目的出发，先看看哪种编程范式最适合这三个目的？

可以看到，大概三种编程范式会脱颖而出，分别对应以上三种目标，分别是过程式编程（pp），面向对象编程（oop）和函数式编程（fp）

pp对机器最为友好，机器执行pp一条一条解释或者编译执行就行了，所以脚本还有硬件相关的领域用pp比较多，几乎所有的脚本都是pp，而同样是编译后的代码，oop和fp的执行效率往往不如pp，所以如果执行速度真的那么重要，一般不得不用pp
oop对阅读最为友好，java最大的卖点就是可读性超强，在任何时候，任何人写的java代码，只要你愿意，是能看懂的，pp和fp写出来的东西，别人未必看得懂
fp对懒惰最为友好，fp为了让你懒，不惜用上各种符号和语法糖来简化你的思维负担，让你最快实现你的目的，论写得快，fp从来都是最快的，编程比赛，第一名一般都是lisp或者haskell，同样算法，用其他语言实现起来，就是不如fp写得快，fp几乎是把人的思维直接翻译成代码，其他p往往需要一次转换
其他还有很多p，但是从目的出发，这三个p各对应一个目标，所以比较适合用来对比和作为判断标准，fp之后其实就已经非常接近对人语言的翻译了，再做一点封装应该就可以用来搞nlp了，这就是为什么lisp经常被用在ai领域的原因

日常工作中，这三者往往需要权衡，任何一个领域失败了，都会让你或者是你的系统完蛋：如果你的系统执行起来非常慢，那客户体验就糟糕得不行，就没人用了；如果你的代码，别人完全看不懂，那会出现软件工程上的经典危机，你的项目最终会亡于维护成本过高；如果你开发代码的速度很慢，那我估计你的考核也不会太好，尤其是现在这种快节奏的社会，搞不好就被开了

那既然我们知道了，这三种p是我们要选择的范式，那再将主流的编程语言，放入这三个范式中去，就显得自然而然了，就得到了这么一个生态链条，这个生态链条是一个深度链条，从下往上封装：

汇编 -> c -> c++ -> java -> kotlin -> scala -> clojure -> haskell

这个演化的过程，就是从pp -> oop -> fp的一个过程

汇编是指令集，这个可以忽略，c就是pp，c++就是pp+oop，java就是oop，kotlin就是oop+少量的fp，scala是oop+fp，clojure是少量oop+fp，haskell就是fp

如果你觉得繁琐，可以简化一下：

c -> c++ -> java -> scala -> haskell

pp -> pp+oop -> oop -> oop+fp -> fp

当然这个链条还不完整，很多还在演化过程中，但是从汇编到scala基本上已经成型了

后者一般依赖于前者提供的环境，比如c用来做os，c++用来做单机的软件，比如jvm，db，browser，用来给上层提供环境，java用来做vert.x，提供其他语言的环境，后面的不是那么绝对，但是可以看到，scala正在给haskell提供运行环境，这就是http://eta-lang.org

我听说，英国的一些本科的cs，已经在大一，就要求学生学习c, java和haskell三门语言，当我们理解了这些语言对应的p之后，再去看这个课程的选择，就会觉得特别合理，因为这样学生可以从大一开始就从不同的角度去理解编程到底是怎么一回事，就不会陷入某一种p甚至是某一个特定语言的狂热当中去，会从多个维度来看编程是肿么一回事

那如果我们把一些常用的功能进一步封装起来，比如跨平台，gc这些，那么我们就可以得到一个完整的vert.x上的生态链条，这个生态链条则相对平面一点，区别于前面的深度链条，是一个广度链条：

pp -> oop -> fp

javascript -> ruby -> groovy -> java -> ceylon -> kotlin -> scala -> clojure -> haskell

clojure和haskell目前都还在往vert.x上搬迁中，这个过程还在进行中，但是基本上如此

愿意的话，可以找找latte在什么位置^_^

那这个时候就问了，如果我们要学会这9种甚至10种语言，怎么办？

这个时候不能陷入语法的细节陷阱中去，否则累死了，要从paradigm上理解这些语言的差异，然后再通过对比语法来记忆，java是一个很好的开始，因为java最啰嗦，但是java的细节最丰富，最容易看懂，java为代表的oop就像是第三人称的描述性语言，像一部小说一样完整，通俗易懂，这里也有一个很有趣的对比，就是三种p对应了三种人称，你我他：

pp就是我，第一人称，我怎么做，每一步其实都可以翻译成独立的一套指令，对机器最为友好，机器最喜欢这种范式了，人怎么做机器就怎么做，所以这是指令式编程
oop就是第三人称，他，他怎么做，oop需要先找到主语，然后才是谓语动词，java里面所有的方法都要被放在一个具体的class里面，用的时候，都要先找到这个主语，也就是class/object，名词，然后才能用这个名词的动作
fp就是第二人称，你，你去做，fp讲究把代码全部封装成函数，函数就是动词，一个纯粹只有动词的语句就是祈使句，就是命令句式，这种句式一般是很不礼貌的，居高临下的，骂人基本上都是这种句式，所以使用这种句式的时候，请注意委婉表达，最好加上称谓否则很容易翻脸，很多国人初到国外时候，外语不太好，操起动词就说
所以fp宣称自己是命令式编程，而pp和oop是指令式编程，指令式最典型的就是pp了，oop介于两者之间，但是oop一般不claim自己是指令式还是命令式，oop最大特点是封装，虽然fp也封装，但是oop的封装是封装成对象，就特别容易理解

这里补充一下命令式和指令式两个定义，我见到的版本，把人的命令，解释成命令式，而计算机汇编那种，叫做指令，所以非fp的是指令式编程，而fp是命令式编程，你可以理解成人更容易理解命令，而不是指令，机器执行指令，然后其他地方，似乎命令式叫做声明式，而指令式叫做命令式，这种翻译不同，值得留意，文中我用的是命令式&指令式，而非声明式&命令式，命令/声明式的英语是declarative，指令/命令式是imperative
而当我们看懂了这些p有些区别之后，再去了解这些p是怎样编程的，pp比较简单，跟oop的区别仅仅在于，它不封装，或者说它不强制封装，但是fp各种幺蛾子就多一点，比如要immutable，要pure function，这个时候就需要针对这些概念逐个攻克，等这些概念都熟悉了之后，再去看细节，看语法，比如lisp/clojure喜欢有一大堆的括号，这些细节问题其实都可以通过ide等方式予以解决，这样就有的放矢，有了理论的指导，再去看那些语法细节，那就是阅读文档和记忆而已了嘛，简单很多

当然这里有一步，就是要理解这些概念，那怎么理解好呢？我觉得哈，比较好的方式，就是从oop+fp的模型入手，在实践中掌握和熟悉这些概念，计算机语言，犹如英语，英语不张口说，不用，很容易就忘记，一样的，计算机语言还是要写，要在实践中去使用它，才不容易忘记，那pure fp的环境对初学者并不友好，那肿么办呢？很简单嘛，我们找oop+fp的环境，那最典型的oop+fp的环境就是actor model啦，而且我们希望找到一个polyglot的环境，让我们有动手的机会，那目前为止，actor model+polyglot的环境做得最好的，显然是vert.x啦，所以如果你学完了java之后，觉得，诶，要探索一下未知的领域，那vert.x是一个非常好的demo以及出发点，在使用vert.x的过程中，你肯定会接触到各种fp的概念，比如immutable，eventbus上发消息就要求immutable，因为reactive programming本身就是fp化的编程模型，vert.x一开始就是按照这个模型制造出来的，这里说一下，协程并不是reactive programming，而是proactive programming，因为协程会把fp/reactive的方式，扳回到oop也就是proactive的方式上去，最近看了不少文章说用了响应式编程，然后里面大谈协程也是醉了，当然这种细节留给读者在搞vert.x过程中慢慢品味了

搞vert.x的每一天都沉浸在编程的欢乐之中，不写代码浑身难受，难以自拔，搞vert.x会上瘾

bye