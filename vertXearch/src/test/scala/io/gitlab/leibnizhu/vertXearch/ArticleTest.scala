package io.gitlab.leibnizhu.vertXearch

import java.io.File

import io.vertx.core.Future
import io.vertx.scala.core.{CompositeFuture, Vertx}
import org.scalatest.FunSuite
import org.slf4j.LoggerFactory


class ArticleTest extends FunSuite {

  private val source: List[Article] = List(
    Article("1", "vert.x-web的源码解析", "lileihanmeimei", "本来应该要写的是eventbus的源码分析的，但是Vert.x中国用户组（群号：515203212）的小伙伴们好像对vert.x-web深入了解的需求更大一些。所以就先分析vert.x-web的实现原理吧。 \n分析完之后发现篇幅较长，请耐心看完。\n如果哪里有写的不好的话，或者不好理解的地方，欢迎在评论区提出来，谢谢。\nvert.x-web主要的功能是路由，还有常用的http相关工具（例如：BodyHandler，SessionHandler）。 本文主要围绕vert.x-web是如何实现路由来展开分析。\n\nvert.x-web最主要的是3个类： Router， Route，RoutingContext。\n\n本文分为以下几部分展开分析：\n\nRouter的api接口和实现类RouterImpl\nRoute的api接口和实现类RouteImpl\nRoutingContext的api接口和实现类RoutingContextImpl\n路由过程\n一.  先来看Router部分。\n\nRouter其实就是Route的容器， 里面装载了全部的Route。当request到来时，通过Router匹配容器里的多个Route。Router把路由的工作丢给RoutingContext做了。\n\nRouter相关的api基本都是创建Route（路由点）的。\n\n例如，route()，get(), get(path),  还有创建正则请求路径的Route等等。\n\n除了这些说些比较重要的。\n\npublic interface Router {\n   //省略若干代码...\n  //路由的入口方法。request进来之后，匹配对应的Route\n  void accept(HttpServerRequest request);\n  \n  //在当前router中，挂载子router。\n  Router mountSubRouter(String mountPoint, Router subRouter);\n  \n  //为当前router设置异常处理器\n  Router exceptionHandler(@Nullable Handler<Throwable> exceptionHandler);\n  \n  //这两个方法是用在子router，不能直接调用。\n  void handleContext(RoutingContext context);\n  void handleFailure(RoutingContext context);\n}\n接着看看RouterImpl实现。\n\npublic class RouterImpl implements Router {\n  //省略若干代码...\n  private final Vertx vertx;\n  //存储Route用的是skiplist，相比于List，时间复杂度从O(n)降低到O(lgn)。\n  //并且用的是线程安全的skiplist\n  //routeComparator是排序比较器。\n  private final Set<RouteImpl> routes = new ConcurrentSkipListSet<>(routeComparator);\n  //用于route的序号，保证route在routes的顺序。\n  //排序前面的route的order比较小。\n  private final AtomicInteger orderSequence = new AtomicInteger();\n  //异常处理器，待会分析该异常处理器的调用处。\n  private Handler<Throwable> exceptionHandler;\n\n  public RouterImpl(Vertx vertx) {\n    this.vertx = vertx;\n  } \n  //随便放出点创建route的代码。此时并未将route加入routes容器中，\n  //而是为route设置handler时才加到routes容器，稍后分析\n  public Route route(HttpMethod method, String path) {\n    return new RouteImpl(this, orderSequence.getAndIncrement(), method, path);\n  }\n  public Route route(String path) {\n    return new RouteImpl(this, orderSequence.getAndIncrement(), path);\n  }\n  \n  public void accept(HttpServerRequest request) {\n    //...\n    //请求委托为RoutingContext，由RoutingContext来实现路由。\n    //这里稍后解释，只需要记住accept方法是路由的入口方法。\n    new RoutingContextImpl(null, this, request, routes).next();\n  }\n\n  //分析挂载，所谓的挂载就是把一个有多个子Route的容器Router放到另一个Router（主router）\n  //mountPoint,挂载点，\n  public Router mountSubRouter(String mountPoint, Router subRouter) {\n    //挂载点的路径必须是确定的，不能用通配符和模式匹配\n    if (mountPoint.endsWith(\"*\")) {\n      throw new IllegalArgumentException(\"Don't include * when mounting subrouter\");\n    }\n    if (mountPoint.contains(\":\")) {\n      throw new IllegalArgumentException(\"Can't use patterns in subrouter mounts\");\n    }\n    //这里就是创建route，然后request达到handler时，转交给subRouter的handleContext。\n    route(mountPoint + \"*\").handler(subRouter::handleContext)\n                           .failureHandler(subRouter::handleFailure);\n    return this;\n  }\n\n\n  public void handleContext(RoutingContext ctx) {\n    //这里创建一个新的RoutingContext，并且把原来的routingContext包装进去，\n    //还有子router(subRouter)的routes也传进去，然后调用next()在subRouter中路由。\n    new RoutingContextWrapper(getAndCheckRoutePath(ctx), ctx.request(), routes, ctx)\n          .next();\n  }\n  public void handleFailure(RoutingContext ctx) {\n    new RoutingContextWrapper(getAndCheckRoutePath(ctx), ctx.request(), routes, ctx)\n     .next();\n  }\n//getAndCheckRoutePath获取挂载路径\n private String getAndCheckRoutePath(RoutingContext ctx) {\n    //currentRoute的路径只有挂载路径，在mountSubRouter方法中可以看的出来。\n    Route currentRoute = ctx.currentRoute();\n    String path = currentRoute.getPath();\n    return path;\n  }\n}\n先大体看看RouterImpl实现过程，看完RoutingContext和Route再回头来看看Router。\n\n再扯扯subRouter的作用。\n\n如果把所有的route都放在一个Router中，当前功能点多的时候，可能就会有好几百个Route。那么请求路由到排在后面Route时，整个路由的开销可能会比较大点。\n\n使用subRouter，可以把同个模块的功能放到一个subRouter下面。\n\n例如： 用户添加，修改，删除，新增等等。\n\n//示例代码\nRouter mainRouter = Router.router(vertx);\nRouter userRouter = Router.router(vertx);\nuserRouter.get(\"/:userId\")...\nuserRouter.post()...\nuserRouter.delete(\"/:userId\")...\nuserRouter.put(\"/:userId\")...\n//挂载到主router上\nmainRouter .mountSubRouter(\"/user\", userRouter);\n//其他模块亦是如此, 最后就是mainRouter挂载了多个功能模块的subRouter\n//当前subRouter也还可以继续挂subRouter 一般没必要 二级基本能满足绝大多数情况了\n\n\n二. 接下来分析Route和它的实现类RouteImpl\n\n上面分析我们知道，Route的创建是在Router调用route或get或post等等时创建的。\n\nroute常用的方法一般就是设置一下handler。链式调用的方式\n\nrouter.route().handler(handler);\n\n相关方法也不少，主要就是设置各种http的参数。启动关闭Route（默认是启动的），还有让当前的Route在Router容器里排到最后的last()方法。\n\n其中最重要的也是最复杂的，就是设置请求路径path。\n\npublic interface Route {\n  //省略若干代码...\n //一般不用此方法，直接在创建route的时候设置\n Route path(String path);\n //route的序号，一般就是用Router中的orderSequence累加生成的。\n Route order(int order);\n \n Route last();\n //启用\n Route enable();\n //关闭\n Route disable();\n}\n其他的就是设置一下http参数，这里就不扯犊子了。\n\n接下来看继续分析Route的实现类RouteImpl\n\npublic class RouteImpl implements Route {\n  //tm的，属性还真不少，没事，一个一个说\n\n  //存储当前route的router，实例化时传入\n  private final RouterImpl router;\n  //http请求方法，默认是支持全部\n  private final Set<HttpMethod> methods = new HashSet<>();\n  //媒体类型\n  private final Set<MIMEHeader> consumes = new LinkedHashSet<>();\n  private final Set<MIMEHeader> produces = new LinkedHashSet<>();\n  //请求路径\n  private String path;\n  //在router中的序号，一般在实例化时传入\n  private int order;\n  //启用状态\n  private boolean enabled = true;\n  //handler集合，一个route可以设置多个handler，但必须得手动调用next方法\n  private List<Handler<RoutingContext>> contextHandlers;\n  //failureHandlers\n  private List<Handler<RoutingContext>> failureHandlers;\n  //当前route是否添加到router时的状态\n  private boolean added;\n  //正则\n  private Pattern pattern;\n  //restful路径中的key集合，例如：/user/:userId， userId就会存储到groups中\n  private List<String> groups;\n  //是否正常化的路径。 例如： user/add, 前面少了个/, true时，会在路由匹配时加上/\n  private boolean useNormalisedPath = true;\n  //使用正则路径的groups。跟groups差不多。稍后分析。\n  private Set<String> namedGroupsInRegex = new TreeSet<>();\n  \n  //设置handler\n  public synchronized Route handler(Handler<RoutingContext> contextHandler) {\n    //把handler加到集合中。\n    this.contextHandlers.add(contextHandler);\n    checkAdd();\n    return this;\n  }\n  private void checkAdd() {\n    if (!added) {\n      //把当前route加到router容器中，并且修改added的状态为已加入状态\n      //failureHandler方法也是如此，也是设置handler时才加入到router容器中。\n      //至于为什么这步才加入到router中，就自己猜猜吧，哈哈哈。\n      router.add(this);\n      added = true;\n    }}\n   //设置路径，构造方法中也调用checkPath和setPath方法，这两个方法才是关键。\n   public synchronized Route path(String path) {\n    checkPath(path);\n    setPath(path);\n    return this;\n  }\n  //这里很简单，检查了一下path是否以/开头。\n  private void checkPath(String path) {\n    if (\"\".equals(path) || path.charAt(0) != '/') {\n      throw new IllegalArgumentException(\"Path must start with /\");\n    }\n  }\n\n  //是否是精确请求路径的标记，true: 请求路径中不包括 : 和 *\n  private boolean exactPath;\n\n  private void setPath(String path) {\n    //包含：即restful方式的请求， 那么创建正则。\n    if (path.indexOf(':') != -1) {\n      createPatternRegex(path);\n      this.path = path;\n    } else {\n      //不是以*结尾，那么就是精确匹配了\n      if (path.charAt(path.length() - 1) != '*') {\n        exactPath = true;\n        this.path = path;\n      } else {\n        //这里多说一句，/user/*/add*/name, 像这种是没用的。\n        exactPath = false;\n        //把*去掉，非精确匹配，那么请求时的路径是以path开头就能匹配了\n        this.path = path.substring(0, path.length() - 1);\n      }}}\n\n  //凌晨2:30点，先睡了，身体要紧。\n  //接下看看怎么创建restful模式的正则\n\n  //该正则的作用转义()$.这四个字符，即在字符前面加\\\n  private static final Pattern RE_OPERATORS_NO_STAR = \n         Pattern.compile(\"([\\\\(\\\\)\\\\$\\\\+\\\\.])\");\n  private void createPatternRegex(String path) {\n    path = RE_OPERATORS_NO_STAR.matcher(path).replaceAll(\"\\\\\\\\$1\");\n    //以*结尾的话，将*换成.*  即以任意字符结尾。 \n    if (path.charAt(path.length() - 1) == '*') {\n      path = path.substring(0, path.length() - 1) + \".*\";\n    }\n    举例路径： /user/:userId/:name 那么下面的正则将会匹配到userId和name\n    //扫描路径中以:开头的字符串。\n    Matcher m = Pattern.compile(\":([A-Za-z][A-Za-z0-9_]*)\").matcher(path);\n    StringBuffer sb = new StringBuffer();\n    //存储路径的key \n    groups = new ArrayList<>();\n    int index = 0;\n    //关于正则的知识了，就是path的匹配的值替换一下加到sb中。\n    while (m.find()) {\n      String param = \"p\" + index;\n      String group = m.group().substring(1);\n      if (groups.contains(group)) {\n        throw new IllegalArgumentException(\"Cannot use identifier \" + group + \" more than once in pattern string\");\n      }\n      m.appendReplacement(sb, \"(?<\" + param + \">[^/]+)\");\n      //把\"userId\", \"name\", 加到groups, groups在匹配Route的时候用\n      groups.add(group);\n      index++;\n    }\n    m.appendTail(sb);\n    path = sb.toString();\n    //以举例路径为例， 此时path=/user/(?<p0>[^/]+)/(?<p1>[^/]+)\n    //这里我不懂路径为什么要变成这样，但是并不影响分析。懂的朋友麻烦请教一下。\n    //最后以path作为regex进行编译正则，pattern在匹配Route的时候使用。\n    pattern = Pattern.compile(path);\n  }\n\n //先分析匹配route的方法，待会再RoutingContext\n  synchronized boolean matches(RoutingContextImplBase context, \n         String mountPoint, boolean failure) {\n    //failure是通过调用RoutingContext的fail方法设置。\n    //如果当前的RoutingContext的状态是失败的，且当前Route的failureHandler已经超过index了\n    //如果当前的RoutingContext的状态是正常的，且当前Route的handler已经超过index了\n    //那么匹配失败\n    if (failure && !hasNextFailureHandler(context) || \n           !failure && !hasNextContextHandler(context)) {\n      return false;\n    }\n    //未启用， 匹配失败\n    if (!enabled) {\n      return false;\n    }\n    HttpServerRequest request = context.request();\n    //设置了请求方法，但是请求的方法不包括在设置的请求方法中，匹配失败。\n    if (!methods.isEmpty() && !methods.contains(request.method())) {\n      return false;\n    }\n    //常规路径匹配，即非正则匹配。pathMatches（下面有分析）返回false的话，匹配失败。\n    if (path != null && pattern == null && !pathMatches(mountPoint, context)) {\n      return false;\n    }\n    //正则路径\n    if (pattern != null) {\n      String path = useNormalisedPath ? Utils.normalizePath(context.request().path()) : context.request().path();\n      //去掉挂载路径， 正则的路径都是以route中的path来匹配的。\n      if (mountPoint != null) {\n        path = path.substring(mountPoint.length());\n      }\n      Matcher m = pattern.matcher(path);\n      if (m.matches()) {\n        if (m.groupCount() > 0) {\n          if (groups != null) {\n            for (int i = 0; i < groups.size(); i++) {\n              /取出setPath时，添加到groups中的key\n              final String k = groups.get(i);\n              String undecodedValue;\n              // We try to take value in three ways:\n              // 1. group name of type p0, p1, pN (most frequent and used by vertx params)\n              // 2. group name inside the regex\n              // 3. No group name\n              try {\n                //取出路径中的值，按照上述的方式去\n                undecodedValue = m.group(\"p\" + i);\n              } catch (IllegalArgumentException e) {\n                try {\n                  undecodedValue = m.group(k);\n                } catch (IllegalArgumentException e1) {\n                  // Groups starts from 1 (0 group is total match)\n                  undecodedValue = m.group(i + 1);\n                }\n              }\n              //group取出来的值作为key, 从path中取出来的值作为value，添加到\n              //RoutingContext的PathParams中（其中就是HashMap）\n              addPathParam(context, k, undecodedValue);\n            }\n          } else {\n           //由于篇幅有限，关于正则路径的就不展开分析了。\n          } \n    //省略若干代码...\n    return true;\n    }\n \n  //匹配路径\n  private boolean pathMatches(String mountPoint, RoutingContext ctx) {\n    String thePath = mountPoint == null ? path : mountPoint + path;\n    String requestPath;\n    if (useNormalisedPath) { //对请求路径做一些处理\n      requestPath = Utils.normalizePath(ctx.request().path());\n    } else {\n      requestPath = ctx.request().path();\n      if (requestPath == null) {\n        requestPath = \"/\";\n      }\n    }\n    if (exactPath) {\n      //精准匹配，如果路径后面有/，先移除，然后调用\n      return pathMatchesExact(requestPath, thePath);\n    } else {\n      //非精准匹配，\n      if (thePath.endsWith(\"/\") && requestPath.equals(removeTrailing(thePath))) {\n        //进入这个if分支的话， 当初设置path时， /xxx/xxx/* 这样类型的。\n        //如果请求路径刚好是 /xxx/xxx时，有这个if分支才能匹配成功\n        return true;\n      }\n      //只要请求的路径以route中设置的path开头就算匹配成功。\n      return requestPath.startsWith(thePath);\n    }\n  }\n\n}\nRouteImpl涉及到的代码比较多， 代码也比较核心，所以进行长篇幅的分析。\n\n先总结的一下Route的重点。\n\nhandler是保存到contextHandlers的ArrayList中，failureHandler保存到failureHandlers的ArrayList中。\nRouteImpl添加到Router容器中时设置handler或failureHandler的时候。\nroute的path设置过程和route匹配过程。（敲黑板）\n\n\n三. 接下来来分析RoutingContext\n\nRoutingContext接口涉及到的接口很多，所以挑比较重要的来分析。\n\nRoutingContext，顾名思义，路由上下文嘛， 就是保存路由整个过程的一些信息，辅助路由。\n\npublic interface RoutingContext {\n\n//匹配下一个route\nvoid next();\n\n//设置当前路由状态为失败的，并重新route找下一个失败的route或者当前route的failureHandler\nvoid fail(int statusCode);\nvoid fail(Throwable throwable);\n\n//往RoutingContext存取，移除数据\nRoutingContext put(String key, Object obj);\n<T> T get(String key);\n<T> T remove(String key);\n//获取RoutingContext全部数据\nMap<String, Object> data();\n\n//获取请求体\nString getBodyAsJson();\n//getBodyAsXXX等等\n\n//重新route，相当于servlet中的forward\nvoid reroute(HttpMethod method, String path);\n\n//restful模式中的路径参数 例： /user/:userId/:name， userId和name\nMap<String, String> pathParams();\nString pathParam(String name);\n\n//请求路径的参数。例如：/user?name=wang007&age=18&hobby=girl\nMultiMap queryParams();\nList<String> queryParam(String query);\n}\n其他的比较简单或者比较很少的就不说了，还有例如Session，Cookie等这些可以另起一个章节来说。\n\nRoutingContext在每次请求来到时创建，在Router的accept方法可以看出来。\n\n接下来分析RoutingContext实现类中的属性\n\npublic abstract class RoutingContextImplBase implements RoutingContext {\n  //route容器，Router中传入\n  private final Set<RouteImpl> routes;\n  //挂载点。 默认是null。\n  protected final String mountPoint;\n \n  protected final HttpServerRequest request;\n  //从routes创建的迭代器\n  protected Iterator<RouteImpl> iter;\n  //当前匹配上route  这个会变的 下个route匹配上的 currentRoute就变成下一个route\n  protected RouteImpl currentRoute;\n  //当前的handler索引。 当匹配上下一个route时，索引重计（设为0）\n  protected AtomicInteger currentRouteNextHandlerIndex;\n  protected AtomicInteger currentRouteNextFailureHandlerIndex;\n  //看下构造方法中创建的属性\n  protected RoutingContextImplBase(String mountPoint, HttpServerRequest request, Set<RouteImpl> routes) {\n    this.mountPoint = mountPoint;\n    //用HttpServerRequestWrapper包装，为了用在reroute方法，重设path和method\n    //默认情况下request是不支持重设path和tmethod，所以只能用这种情况偷鸡一下\n    this.request = new HttpServerRequestWrapper(request);\n    this.routes = routes;\n    this.iter = routes.iterator();\n    currentRouteNextHandlerIndex = new AtomicInteger(0);\n    currentRouteNextFailureHandlerIndex = new AtomicInteger(0);\n  }\n}\n\npublic class RoutingContextImpl extends RoutingContextImplBase {\n  private final RouterImpl router;\n\n  //RoutingContext的put，get数据存储处， 数据类型：HashMap\n  private Map<String, Object> data;\n\n  //restful模式中的路径参数,  数据类型：HashMap\n  private Map<String, String> pathParams;\n\n  //路径请求参数， 一key多value  数据类型：CaseInsensitiveHeaders\n  private MultiMap queryParams;\n\n  //用于headersEndHandlers和bodyEndHandlers中key,为了保证顺序。\n  private AtomicInteger handlerSeq = new AtomicInteger();\n  //response响应完headers时调用, 数据类型：TreeMap\n  private Map<Integer, Handler<Void>> headersEndHandlers;\n  //response响应完body时调用, 数据类型：TreeMap\n  private Map<Integer, Handler<Void>> bodyEndHandlers;\n\n  //调用fail方法设置的failure\n  private Throwable failure;\n  //调用fail方法设置的statusCode \n  private int statusCode = -1;\n\n  //常规化路径，\n  private String normalisedPath;\n\n  private String acceptableContentType;\n  private ParsableHeaderValuesContainer parsedHeaders;\n\n  //这些以后另起篇章再分析了\n  private Map<String, Cookie> cookies;\n  private Buffer body;\n  private Set<FileUpload> fileUploads;\n  private Session session;\n  private User user;\n\n  //next方法， 在下面路由过程分析\n  \n  //设置statusCode，并调用doFail方法  fail(Throwable t)也是类似。\n  public void fail(int statusCode) {\n    this.statusCode = statusCode;\n    doFail();\n  }\n  private void doFail() {\n    //重新设置route的迭代器，清空当前currentRoute\n    //iter有记录当前路由到哪个route的作用，从新设置，意味着从头开始重新路由一遍\n    this.iter = router.iterator();\n    currentRoute = null;\n    next();\n  }\n\n  //判断路由状态是否是失败的。\n  public boolean failed() {\n    return failure != null || statusCode != -1;\n  }\n  \n  //重新route   path中不能包含查询参数中 如果包含将会截断\n  public void reroute(HttpMethod method, String path) {\n    int split = path.indexOf('?');\n    if (split == -1) {\n      split = path.indexOf('#');\n    }\n    if (split != -1) {\n      log.warn(\"Non path segment is not considered: \" + path.substring(split));\n      path = path.substring(0, split);\n    }\n    //设置reroute的method和path\n    ((HttpServerRequestWrapper) request).setMethod(method);\n    ((HttpServerRequestWrapper) request).setPath(path);\n    //清空之前请求的参数\n    request.params().clear();\n    normalisedPath = null;\n    //重置statusCode 失败状态码\n    statusCode = -1;\n    //清空之前请求解析的header\n    response().headers().clear();\n    //清除cookie信息\n    if (cookies != null) {\n      cookies.clear();\n    }\n    if (headersEndHandlers != null) {\n      headersEndHandlers.clear();\n    }\n    if (bodyEndHandlers != null) {\n      bodyEndHandlers.clear();\n    }\n    //重置失败异常\n    failure = null;\n    //从头开始路由，跟doFail方法一样\n    restart();\n  }\n}\nRoutingContext的属性和重要的方法也已经分析完了。\n\n接下来分析路由过程， 本文的重点， 路由通过next方法来完成的。\n\n四.  路由过程\n\n路由的调用过程。\n\n请求通过router.accept方法。\n 然后在accept方法中调用RoutingContext的next方法。这个next方法就是我们可以handler也会经常调用next方法，表示匹配下一个route。\n在next方法中调用RoutingContext一个内部的iterateNext方法\niterateNext方法中逐一调用route的matches方法（前面分析过了），返回true，代表匹配成功，就不再继续匹配了。除非你再手动调用RoutingContext的next方法，代表继续匹配下一个route，如果没有匹配上，那么就返回404， 即使你之前成功匹配过route。\n下面就围绕上面说的这几个点来展开分析。\n\npublic void accept(HttpServerRequest request) {\n    //一次请求到来时，创建一个RoutingContext\n    //第一个参数是挂载点 这里没有挂载，所以是null，\n    //第二个参数router 第三个是request请求 第四个是装载route的容器\n    new RoutingContextImpl(null, this, request, routes).next();\n  }\n\nRoutingContext中的next\npublic void next() {\n    //逐一匹配route  false: route容器中全部route都没匹配上 接着就调用checkHandleNoMatch\n    if (!iterateNext()) {\n      checkHandleNoMatch();\n    }\n  }\n  \n//先分析没匹配上怎么处理\n  private void checkHandleNoMatch() {\n  //这个if分支 至少之前是成功匹配过route的\n  //例如在处理handler时发生异常 或者手动调用RoutingContext.fail方法\n    if (failed()) {\n      unhandledFailure(statusCode, failure, router);\n    } else {\n    //这个分支代表的条件\n    // 1. 全部route都未匹配上 \n    //2.或者成功匹配过route 然后调用了RoutingContext.next方法 却没有再匹配上route\n   \n    //这里有个疑问 为什么在router中不提供一个route未匹配上的handler呢(即404) \n    //就这样直接响应出去了\n    //当然解决方法也有，route.last().handler() 即往route容器最后面加一个route \n    //匹配到该route时，则说明之前所有的route都没匹配上 那么就不会进去到这个else分支了。\n      response().setStatusCode(404);\n      if (request().method() == HttpMethod.HEAD) {\n        response().end();\n      } else {\n        response()\n                .putHeader(HttpHeaderNames.CONTENT_TYPE, \"text/html; charset=utf-8\")\n                .end(DEFAULT_404);\n      }\n    }\n  }\n\n  //处理failure\n  protected void unhandledFailure(int statusCode, Throwable failure, RouterImpl router) {\n    //获取调用fail方法时设置statuCode\n    int code = statusCode != -1 ? statusCode : 500;\n    if (failure != null) {\n      //如果router有设置exceptionHandler的话 执行exceptionHandler\n      if (router.exceptionHandler() != null) {\n        router.exceptionHandler().handle(failure);\n      } else {\n        log.error(\"Unexpected exception in route\", failure);\n      }\n    }\n    //如果未完成响应 \n    if (!response().ended()) {\n      try {\n        response().setStatusCode(code);\n      } catch (IllegalArgumentException e) {\n        // means that there are invalid chars in the status message\n        response()\n            .setStatusMessage(HttpResponseStatus.valueOf(code).reasonPhrase())\n            .setStatusCode(code);\n      }\n      response().end(response().getStatusMessage());\n    }\n  }\n\n//接着分析上next方法中iterateNext\n  protected boolean iterateNext() {\n    //判断是否是失败状态的路由\n    boolean failed = failed();\n    // route可以设置多个handler和failureHandler\n    // 即用户在handler中调用了next方法，先匹配当前route是否还有handler\n    if (currentRoute != null) {  //当前route不为空 即之前成功匹配过 \n      try {\n        //正常状态的路由，并且还存在下一个handler 那么执行下一个handler\n        if (!failed && currentRoute.hasNextContextHandler(this)) {\n          currentRouteNextHandlerIndex.incrementAndGet();\n          currentRoute.handleContext(this);\n          // 结束匹配\n          return true;\n         //失败状态的路由，并且还存在下一个failureHandler 那么执行下一个failureHandler \n        } else if (failed && currentRoute.hasNextFailureHandler(this)) {\n          currentRouteNextFailureHandlerIndex.incrementAndGet();\n          currentRoute.handleFailure(this);\n          //结束匹配\n          return true;\n        }\n      } catch (Throwable t) {\n        if (!failed) { //正常状态的路由 调用fail方法 从头开始匹配失败状态的route\n          fail(t);\n        } else { //已经是失败状态的路由了 那么直接调用异常处理\n          //上面已经分析过此方法里 \n          unhandledFailure(-1, t, currentRoute.router());\n        }\n        //结束匹配\n        return true;\n      }\n    }\n    //上面没匹配上 有3种情况\n    //1. 还未成功匹配过route\n    //2. 调用了RoutingContext的fail方法\n    //3. 调用了reroute的方法\n    while (iter.hasNext()) { // Search for more handlers\n      RouteImpl route = iter.next();\n      //重置handler的index\n      currentRouteNextHandlerIndex.set(0);\n      currentRouteNextFailureHandlerIndex.set(0);\n      try {\n        //matches方法是比较重要的方法 上面已经重点分析了\n        if (route.matches(this, mountPoint(), failed)) {\n          try {\n            //设置RoutingContext当前route为刚匹配上的route\n            currentRoute = route;  \n            //匹配上route 调用相应的handler或failureHandler          \n            if (failed && currentRoute.hasNextFailureHandler(this)) {\n              currentRouteNextFailureHandlerIndex.incrementAndGet();\n              route.handleFailure(this);\n            } else if (currentRoute.hasNextContextHandler(this)) {\n              currentRouteNextHandlerIndex.incrementAndGet();\n              route.handleContext(this);\n            } else {\n              continue;\n            }\n          } catch (Throwable t) {\n            //这里跟上面的if分支一样  就不逼逼了\n            if (!failed) {\n              fail(t);\n            } else {\n              unhandledFailure(-1, t, route.router());\n            }\n          }\n          return true;\n        }\n      } catch (IllegalArgumentException e) {\n        unhandledFailure(400, e, route.router());\n        return true;\n      }\n    }\n    //while循环结束  匹配失败 调用checkHandleNoMatch\n    return false;\n  }\n至此  vert.x-web基本分析完了。建议上下结合看。因为有些重要的方法提前分析完了\n\n 为了方便大家理解， 我要用我最擅长的蜜汁画画，画个图方便大家理解。\n\n算了，不画了。\n\n\n不只是什么画的画\n再来扯扯subRouter，即挂载路由的实现。\n\nsubRouter也是通过route添加在到router容器中，这个route的path是/mountPoint*  \n\n即以/挂载路径开头的请求路径都会匹配上该route，由route进入到subRouter中。\n\n上面提到subRouter要调用了自身的handleContext或handleFailure方法，\n\n直接看关键代码。\n\npublic void handleContext(RoutingContext ctx) {\n  new RoutingContextWrapper(getAndCheckRoutePath(ctx), ctx.request(), routes, ctx).next();\n}\n\npublic class RoutingContextWrapper extends RoutingContextImplBase {\n  //一开始的RoutingContext 即1级RoutingContext\n  //这个RoutingContextWrapper 属于2级RoutingContext\n  protected final RoutingContext inner;\n  private final String mountPoint;\n\n  public RoutingContextWrapper(String mountPoint, HttpServerRequest request, \nSet<RouteImpl> iter, RoutingContext inner) {\n    super(mountPoint, request, iter);\n    this.inner = inner;\n    //获取最初的RoutingContext的挂载点，默认是null \n    //如果不为null的话，RoutingContextWrapper属于3级RoutingContext\n    String parentMountPoint = inner.mountPoint();\n    if (mountPoint.charAt(mountPoint.length() - 1) == '/') {\n      mountPoint = mountPoint.substring(0, mountPoint.length() - 1);\n    }\n    //拼接挂载点\n    this.mountPoint = parentMountPoint == null ? mountPoint : parentMountPoint + mountPoint;\n  }\n  //再看看RoutingContextWrapper的next方法， 跟RoutingContext差不多\n  public void next() {\n    //匹配逐一subRouter容器内的全部route  跟RoutingContext一样\n    if (!super.iterateNext()) {\n      //匹配失败时，再回到父router继续匹配 这里确实设计的很巧妙\n      //分析一下场景， 当subRouter调用它的容器内的route的handler发生异常时，\n      //而当前subRouter又没有设置关于异常的route\n      //此时又回到了父router。 所以为mainRouter设置一个关于异常的route即可。\n      inner.next();\n    }\n  }\n接着来扯扯大家经常遇到的疑问。\n\n Router如何传到多个Verticle中？\n这个问题很简单， 上片分析过SharedData的LocalMap， 把Router存到LocalMap，然后在其他的Verticle再取出来。\n\n示例代码\n\n    //1. 在verticle1中\n    val localMap1 = sharedData.getLocalMap<String, Wrapper>(\"router\")\n    val router = Router.router(vertx)\n    localMap1[\"router1\"] = Wrapper(router)\n\n    //2. 在verticle2中\n    val localMap2 = sharedData.getLocalMap<String, Wrapper>(\"router\")\n    val wrapper = localMap2[\"router1\"]!!\n    val router1 = wrapper.router\n\nclass Wrapper(val router: Router): Shareable\n其实这样传没啥意义， 因为当请求到来时， router还是在调用Router.accept方法所在的线程执行。分析完路由的整个过也没发现有关线程切换的代码吧？ \n\n2. 要想多个请求都全部写在一个HttpServerVerticle很简单，有空扯扯这个吧。（此刻是想快点终结这篇文章了）\n\n总结：\n\n有个重要的问题忘了说， RoutingContext，Router，Route中的很多属性都是延迟初始化的。\n又不知道要总结啥了，我真的是不善于总结的人。\n源码基于vertx-web-3.5.1\n由于平时下班回到家要学习其他的，所以能做到周更就不错了。而且新工作也没有用vert.x，所以平时接触的vert.x就是业余时间自己玩玩了。当然如果深圳有vert.x的工作， 求内推，哈哈哈哈。"),
    Article("2", "vert.x中sharedData源码解析（local模式）", "lileihanmeimei", "接着之前vert.x中future的源码分析完之后，继续分析vert.x core中比较重要组件sharedData\n\n由于sharedData涉及到local模式和cluster模式，涉及到代码比较多，所以本文暂时只对local模式展开深入分析，关系到cluster模式相关类，就简单略过了。后面有时间对cluster模式在深入分析。\n根据sharedData提供的接口，本文分以下几部分来展开分析。\n\nsharedData的接口说明和sharedData的实现类sharedDataImpl相关属性说明。\nAsyncMap的源码分析。\nLock的源码分析。\ncounter的源码分析。\nLocalMap的源码分析。\nsharedData的api和sharedDataImpl\nsharedData的初始化在创建vert.x的构造方法中，就是简单的new了一下并传入vertx实例和clusterManager。\n\nVertxImpl(VertxOptions options, Handler<AsyncResult<Vertx>> resultHandler) {\n    //省略若干代码\n    ...\n    this.sharedData = new SharedDataImpl(this, clusterManager);\n    //local模式的话， clusterManager为null。\n  }\n\n\npublic interface SharedData {\n  //获取集群的map，如果没有集群管理器，将throw exception\n  <K, V> void getClusterWideMap(String name, Handler<AsyncResult<AsyncMap<K, V>>> resultHandler);\n  \n  //获取异步map，如果没有集群管理器，获取的是local模式的异步map\n  <K, V> void getAsyncMap(String name, Handler<AsyncResult<AsyncMap<K, V>>> resultHandler);\n  \n  //获取lock，如果没有集群管理器，获取的是local模式的lock\n  void getLock(String name, Handler<AsyncResult<Lock>> resultHandler);\n\n  //在特定时间内获取lock，如果没有集群管理器，获取的是local模式的lock\n  void getLockWithTimeout(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler);\n\n  //获取counter， 如果没有集群管理器，获取的是local模式的counter\n  void getCounter(String name, Handler<AsyncResult<Counter>> resultHandler);\n  \n  //获取localMap\n  <K, V> LocalMap<K, V> getLocalMap(String name);\n\n}\n可以看到sharedData提供的api非常简洁，不得不说vert.x的api设计很棒。\n\n接着看sharedData的实现类sharedDataImpl\n\npublic class SharedDataImpl implements SharedData {\n  \n  //sharedData是在整个vert.x实例中共享，所以会有并发问题，这里交给了ConcurrentHashMap\n  //来处理并发问题。所以sharedData提供的api可以放心大胆的用。\n  \n  //正在因为存储到ConcurrentHashMap，所以sharedData的数据可以在整个vert.x共享。\n\n  //这里所有ConcurrentHashMap中的数据也是需要线程安全的。\n\n  //获取lock的默认时间 单位：ms\n  private static final long DEFAULT_LOCK_TIMEOUT = 10 * 1000;\n  \n  private final VertxInternal vertx;\n  //集群管理器\n  private final ClusterManager clusterManager;\n  \n  //local模式的AsyncMap存储在localAsyncMaps \n  private final ConcurrentMap<String, LocalAsyncMapImpl<?, ?>> localAsyncMaps = new ConcurrentHashMap<>();\n  \n  //local模式的Lock存储在localLocks\n  private final ConcurrentMap<String, AsynchronousLock> localLocks = new ConcurrentHashMap<>();\n  \n  //local模式的Counter存储在localCounters \n  private final ConcurrentMap<String, Counter> localCounters = new ConcurrentHashMap<>();\n  \n  //localmap存储在localMaps\n  private final ConcurrentMap<String, LocalMap<?, ?>> localMaps = new ConcurrentHashMap<>();\n\n  public SharedDataImpl(VertxInternal vertx, ClusterManager clusterManager) {\n    this.vertx = vertx;\n    this.clusterManager = clusterManager;\n  }\n\n}\n到这一步，sharedData的实现还是很简单的。\n\n接着分析AsyncMap\n\n2.  AsyncMap\n\npublic class SharedDataImpl implements SharedData {\n\npublic <K, V> void getAsyncMap(String name, \n                      Handler<AsyncResult<AsyncMap<K, V>>> resultHandler) {\n    Objects.requireNonNull(name, \"name\");\n    Objects.requireNonNull(resultHandler, \"resultHandler\");\n    //判断集群管理器是否为null，null：local模式\n    if (clusterManager == null) {\n      //这里委托给内部方法\n      getLocalAsyncMap(name, resultHandler);\n    //cluster模式\n    } else {\n      clusterManager.<K, V>getAsyncMap(name, ar -> {\n        if (ar.succeeded()) {\n          // Wrap it\n          resultHandler.handle(Future.\n                   succeededFuture(new WrappedAsyncMap<K, V>(ar.result())));\n        } else {\n          resultHandler.handle(Future.failedFuture(ar.cause()));\n        }\n      });\n    }\n  }\n\n  private <K, V> void getLocalAsyncMap(String name, \n               Handler<AsyncResult<AsyncMap<K, V>>> resultHandler) {\n    //就是从localAsyncMaps中获取数据\n    //接着来看LocalAsyncMapImpl这个类。\n    LocalAsyncMapImpl<K, V> asyncMap = (LocalAsyncMapImpl<K, V>) localAsyncMaps\n                      .computeIfAbsent(name, n -> new LocalAsyncMapImpl<>(vertx));\n    //WrappedAsyncMap这个类，就是简单包装了一下，就是做了入参的参数校验\n    resultHandler.handle(Future.succeededFuture(new WrappedAsyncMap<>(asyncMap)));\n  }\n}\n\n//AsyncMap的数据储存还是委托为了ConcurrentHashMap\n//不同的是存取map数据通过回调的方式（这里的回调是同步的）\n\n//AsyncMap很重要的一点就是实现有时间期限数据的存储。所以value再进一步存储到Holder中，\n//由holder还完成时间期限的工作。\n\npublic class LocalAsyncMapImpl<K, V> implements AsyncMap<K, V> {\n\n  private final Vertx vertx;\n  //map存储数据\n  private final ConcurrentMap<K, Holder<V>> map;\n\n  public LocalAsyncMapImpl(Vertx vertx) {\n    this.vertx = vertx;\n    map = new ConcurrentHashMap<>();\n  }\n\n //LocalAsyncMapImpl中的内部类\n private static class Holder<V> {\n    final V value;\n\n    //定时器的id\n    final long timerId;\n\n    //Time To Live 生存时间时长\n    final long ttl;\n\n    //设置值时的时间戳， now - timestamp > ttl,则过期\n    final long timestamp;\n    \n    Holder(V value) {\n      Objects.requireNonNull(value);\n      this.value = value;\n      //ttl为0， 则没有设置时间期限\n      timestamp = ttl = timerId = 0;\n    }\n    Holder(V value, long timerId, long ttl, long timestamp) {\n      Objects.requireNonNull(value);\n      if (ttl < 1) {\n        throw new IllegalArgumentException(\"ttl must be positive: \" + ttl);\n      }\n      this.value = value;\n      this.timerId = timerId;\n      this.ttl = ttl;\n      this.timestamp = timestamp;\n    }\n    \n    //判断是否有设置时间期限的value\n    boolean expires() {\n      return ttl > 0;\n    }\n    \n    //判断是否 没过期。\n    boolean hasNotExpired() {\n      //如果这里没有设置时间期限的话，一直返回true（即没过期）\n      return !expires() ||\n          //如果有设置时间期限的话，（当前的时间戳 - 设置值的时间戳）< ttl时，则没过期\n          MILLISECONDS.convert(System.nanoTime() - timestamp, NANOSECONDS) < ttl;\n    }\n  }\n\n  //没有设置时间期限的put\n  public void put(final K k, final V v, Handler<AsyncResult<Void>> resultHandler) {\n    Holder<V> previous = map.put(k, new Holder<>(v));\n    \n    //上个元素，且上一个元素上有设置时间期限\n    if (previous != null && previous.expires()) {\n      //取消上个元素的定时器\n      vertx.cancelTimer(previous.timerId);\n    }\n    //响应回调\n    resultHandler.handle(Future.succeededFuture());\n  }\n\n  //有设置时间期限的put\n  public void put(K k, V v, long timeout, \n                      Handler<AsyncResult<Void>> completionHandler) {\n    long timestamp = System.nanoTime();\n    //设置定时任务， 用于清除过期数据，调用removeIfExpired方法\n    long timerId = vertx.setTimer(timeout, l -> removeIfExpired(k));\n    //创建holder并put到map中\n    Holder<V> previous = map.put(k, new Holder<>(v, timerId, timeout, timestamp));\n    if (previous != null && previous.expires()) {\n      vertx.cancelTimer(previous.timerId);\n    }\n    //响应回调\n    completionHandler.handle(Future.succeededFuture());\n  }\n  \n  //清除过期数据\n  private void removeIfExpired(K k) {\n    //判断k是否存在，是的话执行后面这个lambda\n    map.computeIfPresent(k, (key, holder) -> holder.hasNotExpired() ? holder : null);\n  }\n  \n //获取数据\n  public void get(final K k, Handler<AsyncResult<V>> resultHandler) {\n    Holder<V> h = map.get(k);\n    //获取到holder之后，判断有没有过期\n    if (h != null && h.hasNotExpired()) {\n      resultHandler.handle(Future.succeededFuture(h.value));\n    } else {\n      resultHandler.handle(Future.succeededFuture());\n    }\n  }\n}\n通过AsyncMap上面的分析，AsyncMap的ttl是通过vert.x的setTimer定时器来完成的。\n\n接着分析Lock\n\n3. Lock\n\npublic class SharedDataImpl implements SharedData {\n  \n public void getLock(String name, Handler<AsyncResult<Lock>> resultHandler) {\n    Objects.requireNonNull(name, \"name\");\n    Objects.requireNonNull(resultHandler, \"resultHandler\");\n    //获取lock默认时长，10s\n    getLockWithTimeout(name, DEFAULT_LOCK_TIMEOUT, resultHandler);\n  }\n\n  public void getLockWithTimeout(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    Objects.requireNonNull(name, \"name\");\n    Objects.requireNonNull(resultHandler, \"resultHandler\");\n    Arguments.require(timeout >= 0, \"timeout must be >= 0\");\n    if (clusterManager == null) {\n      //local模式\n      getLocalLock(name, timeout, resultHandler);\n    } else {\n      //cluster模式\n      clusterManager.getLockWithTimeout(name, timeout, resultHandler);\n    }\n  }\n  \n  private void getLocalLock(String name, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    //从localLocks获取lock，如果lock不存在，执行后面lambda创建lock。\n    AsynchronousLock lock = localLocks.computeIfAbsent(name, n -> new AsynchronousLock(vertx));\n    //timeout时间期间内获取lock。\n    lock.acquire(timeout, resultHandler);\n  }\n}\n\npublic class AsynchronousLock implements Lock {  \n  private final Vertx vertx;\n  //等待的节点队列，更确切的说法是通知队列。因为这里不会发生阻塞等待\n  private final Queue<LockWaiter> waiters = new LinkedList<>();\n  //代表是否拥有锁\n  private boolean owned;\n  \n  public void acquire(long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    //获取vert.x执行的上下文，一般情况时eventloopContext\n    Context context = vertx.getOrCreateContext();\n    doAcquire(context, timeout, resultHandler);\n  }\n \n  public void doAcquire(Context context, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n    //并发问题通过加锁方式解决\n    synchronized (this) {\n      //判断锁是否在用，\n      if (!owned) {\n        //设置当前线程为锁的拥有者\n        owned = true;\n        //获取锁成功，回调通过context来通知\n        lockAcquired(context, resultHandler);\n      } else {\n       //锁已经被其他线程拥有，则加入通知队列中\n        waiters.add(new LockWaiter(this, context, timeout, resultHandler));\n      }\n    }\n  }\n  //重新加入到eventloop执行回调函数\n  private void lockAcquired(Context context, \n                    Handler<AsyncResult<Lock>> resultHandler) {\n    context.runOnContext(v -> resultHandler.handle(Future.succeededFuture(this)));\n  }\n\n //接着分析加入通知队列，看LockWaiter构造方法\n\n  private static class LockWaiter {\n    final AsynchronousLock lock;\n    final Context context;\n    final Handler<AsyncResult<Lock>> resultHandler;\n    //过期标记\n    volatile boolean timedOut;\n    //是否得到过锁的标记\n    volatile boolean acquired;\n\n    LockWaiter(AsynchronousLock lock, Context context, long timeout, Handler<AsyncResult<Lock>> resultHandler) {\n      this.lock = lock;\n      this.context = context;\n      this.resultHandler = resultHandler;   \n      if (timeout != Long.MAX_VALUE) {\n        //通过setTimer设置超时\n        context.owner().setTimer(timeout, tid -> timedOut());\n      }\n    }\n\n    void timedOut() {\n      synchronized (lock) {\n        //定时任务触发。设置超时任务到触发期间，都没有获取过锁，\n        if (!acquired) {\n          //超时， timedOut用于release方法中做清除节点操作\n          timedOut = true;\n          //且通知调用者。 稍后再release方法中做清除节点的工作。\n          context.runOnContext(v -> resultHandler.handle(Future.failedFuture(new VertxException(\"Timed out waiting to get lock\"))));\n        }\n      }\n    }\n}\n\n接着分析释放锁和通知等待者\n  public synchronized void release() {\n    //从队列头部开始获取没有timedOut的等待节点\n    LockWaiter waiter = pollWaiters();\n    if (waiter != null) {\n      waiter.acquire(this);\n    } else {\n      //waiter == null， 没有等待节点， 设置owned=false。则锁空闲\n      owned = false;\n    }\n  }\n\n  private LockWaiter pollWaiters() {\n    while (true) {\n      //remove & get， 这里做清除节点的工作。\n      LockWaiter waiter = waiters.poll();\n      if (waiter == null) {\n        return null;\n      } else if (!waiter.timedOut) {\n        return waiter;\n      }\n    }\n  }\n\n  void acquire(AsynchronousLock lock) {\n     //标记当前节点获取锁成功，acquired属性用于上面的timedOut方法\n      acquired = true;\n     //回调通知调用者获取锁成功。\n      lock.lockAcquired(context, resultHandler);\n    }\n  }\n获取Lock的过程，并发部分通过synchronized来解决。这里其实加锁倒不用担心性能问题，因为加锁过程很短。就是往linkedList添加数据。然后异步回调等待通知。不会一直阻塞线程。\n\n只有获得lock的线程才能执行。对了，获得lock执行完之后， 记得release。\n\n相比于ReentrantLock等lock的优点就是不会阻塞线程。\n\n\n\n4. 接着分析计数器Counter\n\n public void getCounter(String name, Handler<AsyncResult<Counter>> resultHandler) {\n    Objects.requireNonNull(name, \"name\");\n    Objects.requireNonNull(resultHandler, \"resultHandler\");\n    if (clusterManager == null) {\n      //local模式\n      getLocalCounter(name, resultHandler);\n    } else {\n      clusterManager.getCounter(name, resultHandler);\n    }\n  }\n\n  private void getLocalCounter(String name, Handler<AsyncResult<Counter>> resultHandler) {\n    //从sharedData局部变量localCounters中获取counter\n    //如果不存在，执行lambda表达式创建Counter。\n    Counter counter = localCounters.computeIfAbsent(name, n -> new AsynchronousCounter(vertx));\n    //重新加入到context（一般情况是eventloopContext）执行回调函数\n    Context context = vertx.getOrCreateContext();\n    context.runOnContext(v -> resultHandler.handle(Future.succeededFuture(counter)));\n  }\n\n接着看AsynchronousCounter这个类\n//很简单，把计数的功能委托给AtomicLong来实现。\n//而AtomicLong通过自旋+cas+volatile方式还实现线程安全的计数。\n//这里比较简单，就不再多啰嗦了。\npublic class AsynchronousCounter implements Counter {\n  private final VertxInternal vertx;\n  private final AtomicLong counter;\n\n  public AsynchronousCounter(VertxInternal vertx) {\n    this.vertx = vertx;\n    this.counter = new AtomicLong();\n  }\n}\n\n\n5. 最后分析localMap\n\n public <K, V> LocalMap<K, V> getLocalMap(String name) {\n     //从sharedData中的局部变量localMaps获取LocalMap，\n     //如果不存在，执行lambda计算，创建LocalMapImpl\n     return (LocalMap<K, V>) localMaps.computeIfAbsent(name, \n                           n -> new LocalMapImpl<>(n, localMaps));\n  }\n\nclass LocalMapImpl<K, V> implements LocalMap<K, V> {\n  //sharedData中那个局部变量localMaps，用于清除当前LocalMap\n  private final ConcurrentMap<String, LocalMap<?, ?>> maps;\n  //用于从LocalMaps（maps）清除当前local\n  private final String name;\n  //实际存储数据的map\n  private final ConcurrentMap<K, V> map = new ConcurrentHashMap<>();\n\n  LocalMapImpl(String name, ConcurrentMap<String, LocalMap<?, ?>> maps) {\n    this.name = name;\n    this.maps = maps;\n  }\n  //往localmap添加数据时，做参数校验\n  public V put(K key, V value) {\n    checkType(key);\n    checkType(value);\n    return map.put(key, value);\n  }\n\n //从localmap获取数据时，对value进行copy。\n public V get(Object key) {\n    return copyIfRequired(map.get(key));\n  }\n}\n  //包装类,例如Integer等，String本身是immtuable，所以是线程安全的，不用copy\n  static <T> T copyIfRequired(T obj) {\n    if (obj instanceof JsonObject) {\n      return (T)((JsonObject)obj).copy();\n    } else if (obj instanceof JsonArray) {\n      return (T) ((JsonArray) obj).copy();\n    } else if (obj instanceof byte[]) {\n      //Copy it\n      byte[] bytes = (byte[]) obj;\n      byte[] copy = new byte[bytes.length];\n      System.arraycopy(bytes, 0, copy, 0, bytes.length);\n      return (T) copy;\n    } else if (obj instanceof Buffer) {\n      //Copy it\n      return (T) ((Buffer) obj).copy();\n    } else {\n      return obj;\n    }\n  }\n最后来说说localmap中获取数据时做copy操作。即可以保证使用value时的线程安全。\n\n当自己实现Shareable的接口的类放到localmap不会有copy工作，当然线程安全工作就得由自己保证了。\n\n最后说说map中的computeIfxxx方法都是有延迟初始化的作用。\n\n总结：\n\n毛线，好像没啥可总结的。\n如果有写的不好的地方，欢迎指正。\n本文基于vertx.3.5.1\n最近换了个工作，哎， 又干上了spring。vert.x就得业余时间玩玩了。伤心ing...\n\n由于对集群管理器不是很熟悉。下面有可能跳过cluster模式的sharedData的分析，就是到了eventbus的分析。\n"),
    Article("3", "vert.x中future的源码解析", "lileihanmeimei", "对于vert.x的开发者而言，对于callback hell总是能嗅出一些坏味道。接下来我们看下vert.x中的future如何实现的和如何解决callback hell问题。\n\n先体会一下callback hell的坏味道吧。\n\n\n当这种中间再加点业务处理。callback再多几层，这代码看起来就非常头疼了。\n\n\n像这种把callback hell通过链式的形式表达出来，比较习惯于常人的思维方式。\n\n\n\n本文具体会以下几部分：\n\n1. future的常用实现futureImpl和一些常用的方法。\n\n2. future的高阶函数实现。\n\n\n\n首先看future接口的继承关系。\n\n\nfuture的继承关系\nfuture继承了AsyncResult接口，则future本身可以携带异步结果。同时future的实现类futureImpl也是AsyncResult异步结果的携带者。\n\nfuture同时也集成了Handler，所以很多调用处需要传Handler的地方，可以直接传future。\n\n接下来看future的最常用的实现类FutureImpl。先看下FutureImpl有哪些属性。\n\n\nfutureImpl所有的属性\nfailed，true：这是失败的异步结果。此时throwable不为空。\nsucceeded，true：这是成功的异步结果。如果有设置结果的话，result不为空。\nhandler：真正的异步结果处理器，setHandler方法传入的handler保存在这里。\nresult：结果属性。\nthrowable：异常结果属性。\nfutureImpl是通过future的静态方法调用FutureFactory的方法创建的。这里比较简单不深入分析。\n\n接下来来看常用的方法。complete方法。\n\n public void complete(T result) {\n    //如果当前future代表的异步结果已完成，则tryComplte方法false， \n    //然后throw IllegalStateException\n    if (!tryComplete(result)) {\n      throw new IllegalStateException(\"Result is already complete: \" + (succeeded ? \"succeeded\" : \"failed\"));\n    }\n  }\n\n  public boolean tryComplete(T result) {\n    Handler<AsyncResult<T>> h;\n    synchronized (this) {\n      if (succeeded || failed) {\n        return false;\n      }\n      this.result = result;\n      succeeded = true;\n      h = handler;\n    }\n    if (h != null) {\n      h.handle(this);\n    }\n    return true;\n  }\ncomplete方法委托给tryComplete方法来实现。如果tryComplete方法返回false，则说明此异步结果已经完成了，进入if分支，抛出异常。由此可以看出future的最终状态确定下来，就不再改变。\n\n接下来看tryComplete方法。很简单。就是把结果赋值给result。设置到succeeded为true代表当前AsyncResult已经完成。如果当前已经设置了handler那么就触发该handler。（大多数情况，这是已经设置到handler）。failed方法此时类似。\n\n接下来继续看setHandler方法。\n\n public Future<T> setHandler(Handler<AsyncResult<T>> handler) {\n    boolean callHandler;\n    synchronized (this) {\n      this.handler = handler;\n      //判断当前的future是否已经完成。true：调用传入的handler\n      callHandler = isComplete();\n    }\n    if (callHandler) {\n      handler.handle(this);\n    }\n    return this;\n  }\n\n\npublic synchronized boolean isComplete() {\n    return failed || succeeded;\n  }\nsethandler方法也很简单，就是把handler赋值给属性handler。如果当前future代表的AsyncResult已经完成，那么触发handler。\n\n\n\n再看一下handle方法，future本身作为Handler。看看它是如何实现handle方法的。\n\n public void handle(AsyncResult<T> asyncResult) {\n    if (asyncResult.succeeded()) {\n      complete(asyncResult.result());\n    } else {\n      fail(asyncResult.cause());\n    }\n  }\n还是很简单，就是调用complete方法和failed方法即可。\n\n\n\n接下来接着分析看起来很简单，但是又比较难懂的compose方法。该方法是vert.x解决callback hell很重要的方法。该方法跟fp的flatmap实现原理和思想都差不多。要理解compose方法。最重要的是执行时机不同，执行时机不同，执行时机不同。此处敲黑板，重要的话说3遍。\n\ndefault <U> Future<U> compose(Function<T, Future<U>> mapper) {\n    if (mapper == null) {\n      throw new NullPointerException();\n    }\n    //先创建好future，然后下面返回这个新创建的future。\n    Future<U> ret = Future.future();\n   //给当前future设置handler。这个handler在将来某个时刻执行。\n    setHandler(ar -> {\n      //这个代码块的代码跟外面的代码执行时机不同。\n      //1. 外面的ret，将在当前future的compose方法调用时执行并返回。\n      //2. 在下一个compose方法或者setHandler方法为ret设置handler。\n\n      // 将来某一时刻到了。执行了这个代码块。 到了此时，当前future已经完成，\n      //并且执行handler中的handle方法。\n      if (ar.succeeded()) {\n        Future<U> apply;\n        try {\n        //3. 获取future中的异步结果。调用compose方法的传入mapper这个functionalInterface\n        //4.mapper返回下一个异步操作future（apply）。\n          apply = mapper.apply(ar.result());\n        } catch (Throwable e) {\n       //执行mapper失败，直接设置ret的异常结果。以完成ret这个future，且触发handler的执行\n          ret.fail(e);\n          return;\n        }\n       //5.为apply设置handler。（此时的ret已经完成handler的设置，执行时机不同）\n       //6. 这个apply future又会将在未来某一时刻执行。注意：在未来某一时刻。执行时机不同。\n       //7. 当apply完成时，调用handler。apply自身作为异步结果（AsyncResult），\n       //调用ret（此时ret作为Handler）\n        apply.setHandler(ret);\n      } else {\n       //如果当前的函数是失败状态的，直接设置ret的异常结果。\n       //以完成ret这个future，且触发handler的执行\n        ret.fail(ar.cause());\n      }\n    });\n    return ret;\n  }\n//接下来的代码中会为ret设置handler\ncompose方法比较绕，多读几遍，多理解一下。\n\n把原来需要通过异步回调嵌套才能解决问题的代码换成compose的链式结构的代码，阅读代码的时候就好像顺序执行一样。把异步回调嵌套代码弄到compose方法的mapper中。提高代码的可读性。\n\n懂了上面的compose方法，再看一个比较简单的map方法。所谓的map，就是转换，从一种结果类型转换成另一种结果类型。\n\n default <U> Future<U> map(Function<T, U> mapper) {\n    if (mapper == null) {\n      throw new NullPointerException();\n    }\n    //这里跟上面一样。就是创建一个ret的future，然后为当前的future设置handler。\n    Future<U> ret = Future.future();\n    setHandler(ar -> {\n      //1. 执行到这里时，此时的ret已经完成handler的设置。\n      if (ar.succeeded()) {\n        U mapped;\n        try {\n          //2. 将异步结果的值传入mapper，并返回一个新的类型值。\n          mapped = mapper.apply(ar.result());\n        } catch (Throwable e) {\n          ret.fail(e);\n          return;\n        }\n       //3. 为ret设置异步结果，并触发ret中的handler执行。\n       //4. 这里的ret是作为AsyncResult，而compose方法的ret是作为handler。\n        ret.complete(mapped);\n      } else {\n        ret.fail(ar.cause());\n      }\n    });\n    return ret;\n  }\n //这里ret将会再接下来的代码中进行设置handler\n\n\n总结：\n\n关于future的一些常用方法和一些重要方法已经分析完成。\nfuture的实现也很简洁，功能也相对简单一些。如果想要一些更复杂的操作符。那么推荐实现rxjava。如果大多数情况future能满足业务要求的话，那么直接使用future无妨。\n接下来分析CompositeFuture。这个在vert.x也是比较常用的。"),
    Article("4", "vert.x中CompositeFuture的源码解", "lileihanmeimei", "如果对vert.x中future不熟悉的话，请先看上一篇文章。vert.x中future的源码解析\n\n今天来分析Future实现类中另一个实现CompositeFuture。看名字就大概知道这个类的功能作用。组合future，就是把多个future组合起来。\n\n使用场景：\n\n等待多个future全部成功，然后响应成功操作。如果中途有future失败，那么结束等待，响应失败操作。（即compositeFuture的all方法）\n多个future只要有一个成功，就响应成功操作。如果全部失败的话，响应失败操作。（即compositeFuture的any方法）\n等待多个future全部操作完成，然后响应成功操作，如果中途有future失败，也将继续等待所有的future执行完。如果有future失败，最后的compositeFuture还是失败的。这就是与all方法区别。（即compositeFuture的join方法）\ncompositeFuture主要就是以上几个操作。同时compositeFuture的构造方法也是私有的，所以开发者不能再去扩展compositeFuture的其他操作。（仅仅就上面3种就够了吗，万一开发者想要扩展compositeFuture的其他操作呢？）\n\n本文具体会以下几部分：\n\nCompositeFuture的实现，CompositeFutureImpl\nCompositeFuture的常用方法all，any，join方法源码分析\n先看CompositeFuture的继承结构。\n\n\nCompositeFuture继承结构\nCompositeFuture继承了future。扩展了几个关于获取内部future和内部future状态的方法。这个比较简单，就不展开分析。\n\n接下来先看CompositeFuture的内部实现。\n\npublic class CompositeFutureImpl implements \n           CompositeFuture, Handler<AsyncResult<CompositeFuture>> {\n  //CompositeFutureImpl的所有属性。\n  //1.需要组合的future列表\n  private final Future[] results;\n  //已完成的future数的统计，初始化时为0\n  private int count;\n  //标记CompositeFuture是否已经完成。\n  private boolean completed;\n  //异步结果。该属性判断当前的CompositeFuture是成功还是失败的。\n  //cause不为空，这是个失败的CompositeFuture。\n  //cause== null的话，这是个成功的CompositeFuture。\n  private Throwable cause;\n  //等待被调用的处理器。\n  private Handler<AsyncResult<CompositeFuture>> handler;\n}\n接下来看CompositeFutureImpl内部比较重要的方法setCompleted，其他标记CompositeFuture完成状态的方法都是直接或间接setCompleted。\n\n private Handler<AsyncResult<CompositeFuture>> setCompleted(Throwable cause) {\n    synchronized (this) {\n      //如果CompositeFuture已经完成，那么返回null的handler\n      if (completed) {\n        return null;\n      }\n      //标记完成状态\n      this.completed = true;\n      //设置cause的值，这里可能为null。\n      this.cause = cause;\n      //最后返回handler。NO_HANDLER是个空操作。\n      return handler != null ? handler : NO_HANDLER;\n    }\n  }\n该方法很简单，就是设置值而已。\n\n接下来分析complete方法。\n\n//complete方法跟futureImpl一样，也是调用tryComplete方法。\n //如果tryComplete返回false，则代表当前的CompositeFuture已经完成。进入if分支抛出异常\n  public void complete(CompositeFuture result) {\n    if (!tryComplete(result)) {\n      throw new IllegalStateException(\"Result is already complete: \" + (this.cause == null ? \"succeeded\" : \"failed\"));\n    }\n  }\n\n  //这里只是简单的调用一下setCompleted方法。\n  //如果setCompleted返回的handler为null，则当前的CompositeFuture已经完成，\n  //tryComplete方法返回false。\n  public boolean tryComplete(CompositeFuture result) {\n    Handler<AsyncResult<CompositeFuture>> handler = setCompleted(null);\n    if (handler != null) {\n      handler.handle(this);\n      return true;\n    } else {\n      return false;\n    }\n  }\ncomplete很简单。failed方法也是类似。这里就不分析了。\n\n其他方法跟futureImpl非常类似，如果懂了futureImpl的话，再看懂CompositeFuture 是轻而易举的事。所以这里的其他方法就不深入分析了。\n\n接下来分析比较重要的部分，all方法，any方法，join方法。\n\n还是那句话，执行时机不同。基本异步都是这样。代码不是顺序执行的。这样确实有时候有点难理解。不过没关系，跟着文章的思路来，问题不大。\n\n接下来先分析all方法。先贴上源码。说真的，简单到多看几遍就懂的了。甚至我都有点不想写下去了。\n\n别忘记了all方法的作用，如果忘记了回到本文章开头部分有说明。\n\n public static CompositeFuture all(Future<?>... results) {\n  //注意执行时机。\n  //---------先说all方法的执行时机。（即做了哪些工作）-----\n  //1.调用all方法时，创建一个创建CompositeFuture，返回这个CompositeFuture，然后all方法\n  //  执行完之后，一般就是为CompositeFuture设置handler（setHandler方法）\n  //2.为传入的future数组设置handler，handler这个lambda不是在调用all方法执行时，\n  //  而是future完成（调用complete或failed或handle等）之后再执行的，即所谓的执行时机不同\n    CompositeFutureImpl composite = new CompositeFutureImpl(results);\n    int len = results.length;\n    for (int i = 0; i < len; i++) {\n      results[i].setHandler(ar -> {\n        //--------未来某一时刻到来，即future的执行时机到了------------\n        //此时，all方法已经执行完毕，相关的调用栈也已经没了，\n        //而CompositeFuture通过闭包的方式保存下来。\n        Handler<AsyncResult<CompositeFuture>> handler = null;\n        if (ar.succeeded()) {\n          //这里锁住CompositeFuture，这里有并发情况，因为多个future可能在多个线程执行\n          synchronized (composite) {\n            //当前future是成功的状态，count累加。\n            //所以调用all方法时，count代表succeeded状态的future\n            composite.count++;\n            //当前CompositeFuture未完成且当前future是future数组中的最后一个完成的future。\n            //则标记当前CompositeFuture为succeeded状态。\n            if (!composite.isComplete() && composite.count == len) {\n              handler = composite.setCompleted(null);\n            }\n          }\n        } else {\n          synchronized (composite) {\n           //如果当前future为failed状态，那么也将当前CompositeFuture标记为failed方法。\n           //这里可以看出来，只要一有future失败，CompositeFuture就是失败的。\n            if (!composite.isComplete()) {\n              handler = composite.setCompleted(ar.cause());\n            }\n          }\n        }\n        //调用handler\n        if (handler != null) {\n          handler.handle(composite);\n        }\n      });\n    }\n    //如果future数组为空的话，那么可以直接设置CompositeFuture的结果为succeeded。\n    if (len == 0) {\n      composite.setCompleted(null);\n    }\n    return composite;\n  }\n接着分析any方法。经过上面的all方法，再看any方法，更简单了。所以直接上源码。\n\n public static CompositeFuture any(Future<?>... results) {\n    CompositeFutureImpl composite = new CompositeFutureImpl(results);\n    int len = results.length;\n    for (int i = 0;i < len;i++) {\n      results[i].setHandler(ar -> {\n        Handler<AsyncResult<CompositeFuture>> handler = null;\n        if (ar.succeeded()) {\n          synchronized (composite) {\n            //只要future为succeeded状态，那么就标记CompositeFuture为succeeded\n            //并调用相应的handler,不再等待其他future。\n            if (!composite.isComplete()) {\n              handler = composite.setCompleted(null);\n            }\n          }\n        } else {\n          synchronized (composite) {\n           //future为failed状态时，累加count。\n           //所以调用any方法时，CompositeFuture中的count代表的是failed状态的future数量。\n            composite.count++;\n           //当前CompositeFuture未完成且当前future是future数组中的最后一个完成的future，\n           //则标记CompositeFuture为failed状态。\n            if (!composite.isComplete() && composite.count == len) {\n              handler = composite.setCompleted(ar.cause());\n            }\n          }\n        }\n        if (handler != null) {\n          handler.handle(composite);\n        }\n      });\n    }\n    //如果future数组为空的话，那么可以直接设置CompositeFuture的结果为succeeded。\n    if (results.length == 0) {\n      composite.setCompleted(null);\n    }\n    return composite;\n  }\n最后来分析join方法。\n\n//找一个排在前面的future中的失败结果，如果所有的future都是succeeded，\n//那么返回null，代表CompositeFuture是succeeded的。\nprivate static final Function<CompositeFuture, Throwable> ALL = cf -> {\n    int size = cf.size();\n    for (int i = 0;i < size;i++) {\n      if (!cf.succeeded(i)) {\n        return cf.cause(i);\n      }\n    }\n    return null;\n  };\n\n  public static CompositeFuture join(Future<?>... results) {\n    return join(ALL, results);\n  }\n  \n  private  static CompositeFuture join(Function<CompositeFuture, Throwable> pred, \n                      Future<?>... results) {\n    CompositeFutureImpl composite = new CompositeFutureImpl(results);\n    int len = results.length;\n    for (int i = 0; i < len; i++) {\n      results[i].setHandler(ar -> {\n        Handler<AsyncResult<CompositeFuture>> handler = null;\n        synchronized (composite) {\n          //累计count，这里的count，代表已经完成的future的数量。\n          composite.count++;\n        //如果当前CompositeFuture未完成且当前future是future数组中的最后一个完成的future\n        //则执行handler相关的操作。\n          if (!composite.isComplete() && composite.count == len) {\n           //这个pred就是上面的ALL，可能返回是一个null，\n           //代表所有的future都成功，那么CompositeFuture也是succeeded。\n\n           //pred返回不为空，那么其中有future是failed的，\n           //那么CompositeFuture也是failed的。\n            Throwable failure = pred.apply(composite);\n            handler = composite.setCompleted(failure);\n          }\n        }\n        if (handler != null) {\n          handler.handle(composite);\n        }\n      });\n    }\n    if (len == 0) {\n      composite.setCompleted(null);\n    }\n    return composite;\n  }\n至此，CompositeFuture源码已经分析完了。那么你理解CompositeFuture了吗？\n\n总结：\n\n我比较纳闷的是CompositeFutureImpl的构造方法为什么不公开出去。让开发者自由定义自己想要的CompositeFuture。 可能是因为all，any，join方法基本涵盖了绝大多数场景。\n在日常开发中，用all，any，join方法完全够用了。\n接下来分析sharedData，eventbus的源码实现。\n对了，忘了说， 以上分析的源码是基于vert.x 3.5.1版本的。"),
    Article("5", "Vert.x 微服务架构下实现 MDC Logging 的解决方案（支持 Kotlin Coroutine）", "李飘柔", "1、背景\n在微服务架构的业务系统里，traceId(也称为requestId/correlationId) 在调用链追踪与线上排错过程中扮演着重要角色。traceId 可以串联起多个松散耦合的服务调用链，也可以聚合单一服务内某次请求的所有相关日志信息。这样我们就需要为日志附加 traceId 信息。\n\n为了将 traceId 信息附加在日志里，在传统 J2EE 框架下可以通过 MDC logging 来做到 traceId 记录。相比于简单粗暴的层层传参，MDC logging 有两个显著的优点：\n\n对业务代码无侵入\n规范统一日志格式\n但在 Vert.x 框架中，集成 MDC logging 并不是一件顺滑的事情。\n\n2、MDC 的局限性\n在传统 J2EE 框架里，每个请求都有一个专门的线程来完成，也就是说这个线程会自始至终负责整个 request-response 的执行周期。MDC 功能依赖于线程的 ThreadLocal 变量，只要在 filter拦截器/middleware 里稍加配置，在请求进入时生成一个 traceId 然后通过 MDC 的接口写入当前线程的 ThreadLocal变量。这样在整个请求的过程中，由于线程不变，logger 可以随时拿到相对应的 traceId 进行日志记录。\n\n在 Vert.x 里，线程模型与传统的多线程/线程池模型有显著地区别:\n\n\n简单来说，Vert.x 使用 EventLoop 模型，为了不阻塞 EventLoop,  在涉及到 IO 事件、定时器事件等场景时需要写一个 Handler<E> 类型的回调函数。Handler<E> 是一个函数接口(FunctionalInterface), 在 Kotlin 和 Java 8 里面经常以 lambda 的形态出现。在使用 http-client, 各种 db-client, eventbus.send() 与 context.executeBlocking() 等位置时会遇到这个类型的参数。在程序执行过程中，这些 Handler 会被封装成 Runnable 对象，通过 TaskQueue 提交给 EventLoop 进行处理。问题就出现在这里，所有的 Handler都会被单一的 EventLoop 线程执行。\n\n线程模型的变化暴露出 MDC logging 的设计局限：MDC logging 能正常工作的前提是假设相同的线程独占请求的整个生命周期。在 Vert.x 这类异步系统里，这个前提是不存在的。没有线程变量可以作为依赖能够让 logger 获知跟随完整的请求调用链。\n\n有人会想到，既然只有一个单一线程，那利用时间序，在请求排队执行的过程的起始位置，去进行 MDC.put() 是否可以？\n\n答案也是不行。虽然这些 Handler 在提交到 TaskQueue 时是有序的，但是他们经过 EventLoop 的分发后，Hander 的执行与它对应的原请求逻辑的执行已经从时间上被割裂开来。某个请求里提交的 Handler 很可能会在另一个不同请求的逻辑之前或之后才执行。导致 MDC 里的值被错误的覆盖。\n\n以代码为例阐述这种情形，假设我们有一个 Restful 接口，替用户取回某只股票的行情信息：\n\noverride suspend fun call(context: RoutingContext): SillyResponse {\n    try {\n        MDC.put(\"TRACE_ID\", context.getCurrentTraceId())\n        val quoteResult = quoteCli.getQuote(\"sh600030\").await()\n        return SillyResponse(200, QuoteResponse(quoteResult))\n    } catch (err: Exception) {\n        return SillyResponse(500)\n    }\n}\n在路由的逻辑里，后台服务会通过发 HTTP 请求从新浪的股票 API 里获取行情\n\nfun getQuote(stockCode: String): Future<String> {\n\n    val future = Future.future<String>()\n\n    client.getAbs(\"$baseUrl/list=$stockCode\")\n            .timeout(timeout)\n            .send {\n                if (it.succeeded()) {\n                    val response = it.result()\n                    val result = when (response.statusCode()) {\n                        200 -> {\n                            logger.info(\"成功获取行情信息...\")\n                            response.bodyAsString(\"GBK\")\n                        }\n                        else -> \"error occur not 200!\"\n                    }\n                    future.complete(result)\n                } else {\n                    future.complete(it.cause().message)\n                }\n            }\n    return future\n}\n在执行过程中，代码会先执行到 quoteCli.getQuote(\"sh600030\") 紧接着在 getQuote 函数里，调用 send 的时刻，将send 的参数（包括花括号的一整个 lambda 字面量）提交到 EventLoop.\n\n但是在多个请求并发的时候，有可能当前第 11 个请求执行完 MDC.put 这两句，紧接着开始执行第9个请求所提交的 Handler 回调。那么在回调函数里的 logger 从 MDC 里取到的显然就是错误的值（MDC 已经被后续请求覆盖）。\n\n如果回落到层层传参的方式，在 Vert.x 的语境下，可以用 RoutingContext 来记录 traceId（其实任意对象都可以），由 controller 传参到 service 再传参到 dao 层。这种方案的缺点显而易见：层层传参的方式将框架逻辑侵入到业务层，需要所有开发人员感知，不仅引入额外工作量，而且让业务方法的意义变得不纯粹。\n\n3、方案分析与 wrapper 改造\n在事先知道哪些调用会导致执行上下文被切换的情况下，可以构造一个 wrapper 函数，wrapper 函数的用途是：1）声明 Handler 时捕获当前线程的外部变量，然后送入 Handler(lambda) 里面。2）执行时取出外部变量，通过MDC 的接口写入当前线程的 ThreadLocal. 这一块利用到闭包的基础知识。\n\n接下来开始动手进行代码改造，只要注意到第二行的执行发生在 wrapper 被调用时，这时我们还位于原线程内。Handler 后面的花括号体里面声明的语句在未来执行，到那时线程已经被切换。\n\ninline fun <E> traceable(crossinline transform: (E) -> Unit): Handler<E> {\n    val traceId = MDC.get(TRACE_ID_CTX_KEY)\n    return Handler {\n        MDC.put(TRACE_ID_CTX_KEY, traceId)\n        transform(it)\n    }\n}\n4、中间件改造 -- middleware handler\n接下来是比较基础的一步，思路很简单：通过 middleware 提取 upstream 服务的 traceId\n\n作为请求的接入层，首先要获取上游请求携带的 traceId (Line8)\n\n如果自己就是最上游服务或 Gateway 服务，当请求没有携带 traceId 时，可以选择就地生成一个 traceId (Line8)。\n\n然后将获取到或者新生成的 traceId 通过 MDC 接口存入当前线程的 ThreadLocal 里(Line9). \n\n// 约定 traceId 在 requestHeader 里的 key 名称\nconst val TRACE_ID_HEADER_KEY: String = \"x-trace-id\"\n// 约定 traceId 在系统里各种上下文对象的 key 名称\nconst val TRACE_ID_CTX_KEY: String = \"TRACE_ID\"\n\nclass TraceIdHandler : Handler<RoutingContext> {\n    override fun handle(ctx: RoutingContext) {\n        val traceId = ctx.request().getHeader(TRACE_ID_HEADER_KEY) ?: UUID.randomUUID().toString()\n        MDC.put(TRACE_ID_CTX_KEY, traceId)\n        ctx.next()\n    }\n}\n\n\n最后，将这个中间件配置在 Router 里，要放在业务路由的前面：\n\nval router = Router.router(vertx)\n// 配置其他中间件 handler 略\nrouter.route().handler(TraceIdHandler())\n// 配置业务路由的 handler 略\nreturn router\n\n\n5、收尾工作 -- 请求传递与 wrapper 的使用\n完成以上步骤后，请求在进入 Vert.x 的路由后，一个 TraceId 就会写入处理当前请求的线程变量，logger 可以通过 MDC 机制获取到 traceId，输出到日志里。后面只要保证在构建 Handler 对象时，用上述的 wrapper 函数包装一下 lambda 即可。\n\n还有一些收尾工作。在服务间互相调用 RPC 时，需要服务间传递当前的 traceId. 以 HTTP 请求为例，这里利用 Kotlin Extension 语法，为本服务发出的下游请求通通附上 traceId:\n\nfun <T> HttpRequest<T>.withTrace(): HttpRequest<T> {\n    return this.putHeader(TRACE_ID_HEADER_KEY, MDC.get(TRACE_ID_CTX_KEY))\n}\n最后，一个完整的 HTTP 调用示例如下：\n\nclass DemoHttpClient @Inject constructor(private val client: WebClient) {\n    private val logger = LoggerFactory.getLogger(\"DemoHttpClient\")\n    fun getQuote(stockCode: String): Future<String> {\n        val future = Future.future<String>()\n        client.getAbs(\"http://hq.sinajs.cn/list=$stockCode\")\n                .withTrace()\n                .timeout(3000)\n                .send(traceable {\n                    if (it.succeeded()) {\n                        val response = it.result()\n                        val result = when (response.statusCode()) {\n                            200 -> {\n                                logger.info(\"成功获取股票行情信息...\")\n                                response.bodyAsString(\"GBK\")\n                            }\n                            else -> \"error occur not 200!\"\n                        }\n                        future.complete(result)\n                    } else {\n                        future.complete(it.cause().message)\n                    }\n                })\n        return future\n    }\n}\n\n\n6、Vert.x 的异步机制与 Kotlin Coroutine\n接下来扯点附加话题，在 Vert.x 里有这样四种处理异步的机制:\n\ncallback\nio.vertx.core.Future\nRxJava\nKotlin Coroutine\n前两种由 vertx.core 原生提供。首先由于 callback hell 的原因，任何时候都不建议使用第一种写法。第二种 Future 类型可以借助 compose 操作符，将原本嵌套回调的逻辑写成一个线性化回调的表达。\n\n后两种机制属于 ext 包提供的高阶功能。Rx 对于 Android 工程师来说应该再熟悉不过了。抛开更加丰富的操作符(高阶函数)和额外支持连续事件发射的 Observable/Flowable 不谈，在大多数譬如 Http 请求的场景下，Rx 的写法与 Future 是趋同的 (flatMap vs compose    Single<T> vs  Future<T>). 偶尔在表达复杂的异步组合嵌套分支等场景时，使用 Future 或 Rx 表达逻辑也是件有挑战的事情。\n\n这里还有最后一种机制 -- Kotlin Coroutine. 得益于 Coroutine 的 high level API，在面对异步调用时，可以把闭包、回调、Rx 等概念和用法通通抛于脑后。就像写同步程序一样用 if-else 表达分支, 用 try-catch 处理异常。将代码完全变成最原始的同步线性表达\n\n\n综上原因，在我司的开发规范中，建议开发人员一律使用 Kotlin Coroutine 的方式书写处理逻辑。\n\n回归主题，在之前的改造步骤里，wrap Handler 的思路已经可以 cover 到 callback, Future<T>与 Rx 三种情况。但是 Kotlin Coroutine 的引入使得情形更复杂化了。举个例子(伪代码)：\n\nfun handleLogin(userId: String, pwd: String) {\n    val userIdAfterTrim = userId.trim()\n    webClient.registerTokenCallback(userIdAfterTrim, traceable { \n        token -> {\n            Thread.sleep(2000)\n            ctx.response.end(token)\n        }\n    })\n    logger.info(\"已获取token\")\n}\n在上面一段示例里，handleLogin 函数体的三行函数调用都是在同一时间连续执行完成的。在这个时间段内，MDC 里还是正确的值。而由于 wrapper 的存在，我们提交的 lambda 字面量也会在未来执行时，将 MDC 里存储的 traceId 正确覆盖。\n\n接下来把代码修改成等价的 coroutine 的形式:\n\nsuspend fun handleLogin(userId: String, pwd: String) {\n    val userIdAfterTrim = userId.trim()\n    val token = webClient.registerTokenSuspend(userIdAfterTrim) // suspend\n    delay(2000L) // suspend\n    ctx.response.end(token)\n    logger.info(\"已获取token\")\n}\n在 Vert.x 里， CoroutineDispatcher 是由 vertx-lang-kotlin-coroutines lib 提供的适配。在上面代码里，每一处 suspend 函数的调用，所对应的 continuation 还是要回归 EventLoop 重新派发。Coroutine 引入的问题跟之前 Handler 引入的问题原理是相似的：和之前 Handler 的执行一样，suspend 函数的调用点，也同样割裂了正常逻辑与 continuation 逻辑的执行时机。\n\n7、支持 Kotlin Coroutine\n之前有分析到，如果想达成 MDC logging 的效果，需要有一个用于存储数据的变量能跟踪并覆盖一个请求的生命周期。在传统 J2EE 开发里，这个角色是线程/ThreadLocal。在 Coroutine 的语境下，CoroutineContext 可以作为 ThreadLocal 的一个替代。\n\n对于 Vert.x-Web 来说，启动 Coroutine 的时机是在业务路由的部分。这样对于每个请求，都有一个 Coroutine 完整的跟随整个请求执行全程。所以我们可以利用这个负责单一请求的 Coroutine 所对应的 CoroutineContext 来记录传递 traceId 信息。这里要留意两点前提:\n\nlogging 类库的 MDC 从线程 ThreadLocal 里获取数据\nCoroutine 在执行时是依托于一个具体线程\n我们的方案思路是，实现一个自定义的 CoroutineContext 用于存储 traceId. 在这个 Coroutine 被调度器 resume 时，将当前 Coroutine 对应的 CoroutineContext 里面所存储的 traceId 变量，通过 MDC 的接口来直接写入这个 Coroutine 所绑定/对应线程的 ThreadLocal. 这样这个 Coroutine 所 cover 的逻辑里，logger 都能从 MDC 获取到正确的 traceId.\n\n（是不是有点绕✧(≖ ◡ ≖✿)）\n\n首先，需要在 Coroutine 被调度时，做一个拦截。这里需要动用到 Kotlin Coroutine 的 low level API. 官方 Kotlin Coroutine 的 API 当中提供了 ContinuationInterceptor 接口，它是一个拦截器，可以把对协程的操作拦截，传入的是原始的 Continuation，返回的我们 wrap 之后的 Continuation，这样就可以实现我们的目的了。\n\n这样，利用 ContinuationInterceptor 接口实现一个自定义的 CoroutineContext，它额外存储一个 traceId，每当 Coroutine 被 resume 时，将持有的 traceId 通过 MDC 写入当前线程. 代码如下： (感谢评论区 @金阳阳 提醒，这里的逻辑可以简化）\n\nimport org.slf4j.MDC\nimport kotlin.coroutines.experimental.AbstractCoroutineContextElement\nimport kotlin.coroutines.experimental.Continuation\nimport kotlin.coroutines.experimental.ContinuationInterceptor\nimport kotlin.coroutines.experimental.CoroutineContext\n\nconst val TRACE_ID_CTX_KEY: String = \"TRACE_ID\"\n\nclass TraceableCoroutineContext(private val traceId: String,\n                                private val dispatcher: ContinuationInterceptor\n) : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor {\n\n    override fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T> =\n            dispatcher.interceptContinuation(Wrapper(continuation))\n\n    inner class Wrapper<in T>(private val continuation: Continuation<T>) : Continuation<T> {\n        private inline fun wrap(block: () -> Unit) {\n            MDC.put(TRACE_ID_CTX_KEY, traceId)\n            block()\n        }\n        override val context: CoroutineContext get() = continuation.context\n        override fun resume(value: T) = wrap { continuation.resume(value) }\n        override fun resumeWithException(exception: Throwable) = wrap { continuation.resumeWithException(exception) }\n    }\n}\n最后一点就是 Coroutine Builder 的调用示例，脚手架里我选择通过让业务路由的 Handler 继承 AbstractCoroutineHandler 来获得使用 Coroutine 的能力。在 AbstractCoroutineHandler 的实现里，仅需把 launch 的参数由原来的 VertxDispatcher 换成我们包装后的 CoroutineContext 即可。示例如下：\n\nimport io.vertx.core.Handler\nimport io.vertx.core.logging.LoggerFactory\nimport io.vertx.ext.web.RoutingContext\nimport io.vertx.kotlin.coroutines.dispatcher\nimport kotlinx.coroutines.experimental.launch\n\nabstract class AbstractCoroutineHandler : Handler<RoutingContext> {\n\n    abstract suspend fun call(context: RoutingContext): CommonResponse\n\n    override fun handle(ctx: RoutingContext) {\n        val traceId = MDC.get(TRACE_ID_CTX_KEY)\n        launch(TraceableCoroutineContext(traceId, ctx.vertx().dispatcher())) {\n            try {\n                val respDTO = call(ctx)\n                val response = ctx.response()\n                response.statusCode = respDTO.status\n                respDTO.header?.let { it.forEach { k, v -> response.putHeader(k, v) } }\n                response.end(respDTO.toString())\n            } catch (e: Exception) {\n                ctx.response().setStatusCode(500).end()\n            }\n        }\n    }\n}\n\n\n综合上述改造，可以在以 Vert.x 为基础的微服务架构中，实现出一套完整的 MDC logging 方案。该方案具有较低的业务侵入性，仅需调用高阶函数 traceable 去包装 lambda, 也可以进一步选择在脚手架层，通过重新实现这些会导致线程切换的 API 做到对业务代码的零侵入。"),
    Article("6", "初创团队选择 Vert.x 的避坑考虑和上手资料", "牛传欣", "（2018-04-17更新：修正关于 Vert.x - From zero to (micro)-hero 的评述）\n\n（2018-02-22更新：增加关于多语言选择内容，增加一篇教程）\n\n最近需要做一个可穿戴 IoT 的全栈应用，决定采用关注了很久的 Vert.x 框架。 团队只有不到3人，之前的项目经历多是 C/C++, Clojure 和 Python，所以迁移到 Vert.x 有些学习成本。一方面是对概念和工具不熟悉，另一方面则是希望了解 Vert.x 在项目中的最佳实践，尽量少踩坑。\n\n这篇文章列出一些我们在技术选型时的考虑，以及觉得很有启发的参考项目或教程，希望对于其他迁移型 Vert.x 初学者有所帮助。\n\nVert.x 能解决的问题\n开源的 Vert.x 其实不是一个框架，而是一个以“异步非阻塞”编程模型为核心思想的工具集。它基本上囊括了开发网络应用时需要用到的所有组件，不管是搭建服务、路由管理、用户权限理、数据库对接、网络通讯、集群管理……都可以用 Vert.x 搞定。\n\nVert.x 的另一个重要特性是支持7种编程语言，需要糙快猛时可以用脚本语言（如 Ruby/Groovy，可惜暂不支持 Python），需要专注数据处理则可以用函数式语言（如 Scala/Kotlin，后面有望加入 Haskell 和 Clojure），需要兼顾前后端时可以用 Javascript. \n\n\n支持7种开发语言是 Vert.x 主打的一项特性\n而且，Vert.x 允许同一个项目的不同模块用不同语言来开发，也就是 polyglot. 考虑到初创团队成员加入时的自带技能往往并不一致，所以 polyglot 也是一个对初创团队很友好的特性。\n\n写作本文时 Vert.x 刚刚发布了3.5.1版本，Github 星标 7300+，充分显示了这个工具集的健壮程度。值得一提的是，Vert.x 的好几位贡献者来自中国。近期的一项重要功能——对 kotlin-coroutine 的支持——就是出自上海网友 steam1984 之手. \n\n补充一段知乎 Vert.x 著名答主 \n@圆胖肿\n 的评论，Vert.x 应该使用那种语言开发？\n\n如果之前熟悉c/c++的，直接上java\n如果之前熟悉python的，用groovy，groovy跟python很接近，是java化的python\n如果之前熟悉clojure的，那就用我们提供的支持\n这样三个人都学点新的东西，就可以通过vert.x整合起来了，具体的整合可以参考专栏之前的文章：Vert.x的一个常见问题以及多语言制霸环境配置\n初创团队为什么选择 Vert.x \n初创阶段，由于 Vert.x 功能全面、允许用多种语言开发，所以对初创小团队而言能够激发出较高的生产力。而且开发者社区活跃，所以技术虽新，却也不至于掉到坑里没人捞。\n\n等到用户规模上去以后，Vert.x 具有 JVM 娘胎里带来的稳定性优势，而又通过类似 Node.js 的异步范式保证了多用户性能和可扩展性。据此分析，采用 Vert.x 做的软件项目如果一不小心起飞了，不用经历“脚本 -> Java”这种互联网业常见的转平台之痛。\n\n总结一下，我们认为：\n\nVert.x 是一个不管“从0到1”还是“从1到N”阶段都适用的工具集。\nVert.x 参考项目及上手资料（不断更新中）\n官方的 vertx-examples 应该是上手的最佳资料了。它与 Vert.x 同步更新，所有例子都给出了直接可以运行的工程文件，用 Intellij IDEA 等 IDE 可以直接跑。不过， vertx-examples 里面给出的都是一个个小品级的例程，拿来作为项目的参考还是零散了一点。\n\n此外，由于Vert.x 不是框架，所以对代码的组织结构没有什么限制。这对于项目经验丰富的开发者而言是加分项，但对于初学者来说太 free style 了也会增加上手难度。\n\n下面把网上能够找到的 Vert.x 参考项目和教程汇总一下，方便初学者们找到一款与自己需求类似的原型，目的是通过阅读和重构来上手。评述部分比较侧重我们的可穿戴 IoT 需求，即数据实时性要求较高，几乎类似于网络游戏。\n\n1）官方的用 Vert.x 搭建 Wiki 教程:\n\n网址：教程，Github repo \n要点：前后端通信，Verticle 间通信，异步模型\n评述：如果做对实时性要求没有那么高的应用（非游戏、非 IoT），那么这个教程就非常够用了。\n2）A multi-user realtime game by Burr Sutter: \n\n网址：Youtube 视频，Github repo\n要点：Reactive 编程，eventbus 通信\n评述：非常惊艳的现场演示，服务器—客户端实时互动，玩家间实时互动，绝对的一 demo 胜千言。不过除了几个视频以外没找到任何的文字教程，Github 上的文档也写的比较简单，所以没有实际测试过。但 Burr Sutter 的几次演讲视频的确是我们最初对 Vert.x 动心的原因。\n3）Vert.x console: \n\n网址：Github repo，Youtube 演示视频\n要点：Vue.js，docker，实时监控\n评述：由英语很棒的青年开发者 Yunyu Li 在 GSoC 2017 中贡献，由于 Vert.x 3.5.1 刚刚修复了此前 web client 的一个 bug，新版 vertx-console 还没来得及测试。整体上是一个完成度相当高的全栈项目，尤其是监控部分对于 IoT 应用非常关键。\n4）InMood4Life: \n\n网址：博客文章，Github Repo\n要点： Gradle 项目，完全 Groovy 开发，IoT，外设协同\n评述：众多上手项目中唯一一个不用 Java 开发的，使用了 Gradle + Groovy 这个组合。同时这个项目桥接了蓝牙设备，体现了 Vert.x 在软硬件协同项目中的前景。这类项目常见的上手难度在于没有那几样外设则无法跑起来，只能看看代码过过干瘾。\n5）Vert.x starter: \n\n网址：https://vertx-starter.jetdrone.xyz/, 视频演示\n要点：增减组件、配置依赖关系、前后端匹配\n评述：Vert.x 主程之一 pmlopes 做的最小项目生成器，点点按钮就能生成工程文件。我们主要研究了一下用 Maven (Java/Kotlin)+ Vue.js 配置出来的起步工程，觉得是很好的全栈上手参考。Java + Maven 组合应该是作者主要精力所在，经测可用; Java + Gradle 的可配置项少一点，但也经测可用。Kotlin + Maven 生成项目有 bug，反映给作者后打了补丁，但也可以看出可能暂时不是维护重点。添加 Vert.x 的模块很方便，但只是添加了 maven 包依赖，没有起始代码。相比之下， Clojure 的 Luminus 项目功能与之类似，但每加一个包都会生成相应的起始代码，大大降低了上手难度。另外一个问题是几乎没有文档，牵涉到前端的运行过程要看上面的视频演示。Vert.x 官方也有一个 starter，与 pmlopes 自己的私房 xyz starter 功能类似，但是要简单一点。猜测两个 starter 同源，应该会合并。\n5）一个基于 microservice 的实时商品报价平台样例\n\n网址：Vert.x - From zero to (micro)-hero\n要点：分布式、微服务 microservice、RxJava、实时监控\n评述：重点推荐。Vert.x 主创人员 Clement Escoffier 和 Julien Viet 创作的一个内容翔实的教程，把框架代码写好了，让初学者把核心业务代码填到需要的地方去。提供了懒人式打开即用的源代码，最终的效果是一个有前后端、实时曲线、服务追踪的比较全面的样例工程。\n6）Vertx Blueprint (三个项目）：\n\n网址：博客文章，Github repo (Todo, Kue, Micro Shop)\n要点： 前后端全栈、Eventbus 通信、微服务 microservice 架构、docker\n评述： 由杭州网友 sczyh30 在 GSoC 2016 中贡献，三个例子循序渐进，质量很高。第三个 Micro Shop 的例子是一个全栈的电子商务网站，全部 docker 部署，啃下来就基本上明白 Vert.x microservice 在生产中怎么做了。不过 Micro Shop 跑起来需要自己配置 docker-machine 环境。在测试中发现代码与最新版本的 Keycloak 用户权限管理模块有点冲突，作者正在修改中。\n7）VertxUp / VertxZero: \n\n网址：Vertx Zero Up Framework\n要点：Dependency Injection、与 Spring 的对应理解、复杂项目组织方式\n评述：我们之前没有 Spring 开发经验，这个项目理解起来有些困难。但对于熟悉 Spring 的开发者是很好的迁移途径，由重庆网友 silentbalanceyh 开发。\n8）基于Vert.x和RxJava 2构建通用的爬虫框架 \n\n网址：文章，Github repo \n要点：爬虫、http client\n评述：爬虫功能与我们这次的 IoT 应用稍有不同，但也是web app 中的一个常见需求。由网友沈哲开发。\n9）另一个基于微服务的例子\n\n网址：文章，Github repo\n要点：异步与 MongoDB 通信，vertx-config，Consul 服务发现\n评述：主要阅读了教程文章，测试环境介绍得不太全所以没有实际测试。但项目就两个模块，结构比较清晰，适合初学时阅读理解。"),
    Article("7", "Clojure: Hello Vert.x (vertx-lang-clojure发布)", "圆胖肿", "previous in 白木城全栈：\n\n圆胖肿：在Vert.x上实现Clojure语言支持的探索\n\u200Bzhuanlan.zhihu.com\n图标\n圆胖肿：Vert.x上的Clojure语言支持（项目已开源）\n\u200Bzhuanlan.zhihu.com\n图标\nsummary：vertx-lang-clojure 3.5.1.1正式发布到maven central上去了，用户可以通过添加以下依赖实现vert.x上的clojure语言支持：\n\n  <dependency>\n            <groupId>com.w2v4</groupId>\n            <artifactId>vertx-lang-clojure</artifactId>\n            <version>3.5.1.1</version>\n        </dependency>\n或者在gradle中：\n\ncompile 'com.w2v4:vertx-lang-clojure:3.5.1.1'\n当然还有clojure用户比较喜欢的lein：\n\n[com.w2v4/vertx-lang-clojure \"3.5.1.1\"]\n为什么这么做，这么做的意义何在，理由，why？\n主要目的是弥补Vert.x polyglot上FP语言的短板，同时Clojure社区自身也缺乏一个Actor Model实现，所以无论是把Vert.x带给Clojure还是把Clojure带给Vert.x都有重要意义，解决问题首先解决有跟无的问题。\n\n我该怎么用，how？\n下面解决怎么用的问题，一步一步引导用户来创建一个hello from vert.x！程序，我们可以在http://vertx.io的主页上看到，Vert.x上所有语言都有一个hello from vert.x的师范程序，我们也照葫芦画瓢，做一个类似的hello程序出来，代码其实很简单，主要是内容。\n\n我们知道，maven项目下，src文件夹会有main和test两个文件夹，以main文件夹为例，main文件夹下面会有java和resources两个文件夹，java文件夹下放的是java源文件，resources文件夹下放的是各种资源文件，在编译打包的时候，maven会将java文件夹下的文件编译成class文件，然后拷贝到对应的jar根目录下，而resources下的文件则会被直接拷贝到jar根目录下，然后再将jar根目录打包成jar文件，其实就是一个zip文件。\n\n那clojure在maven项目下的结构也类似，只是在main文件夹下多了一个clojure文件夹，跟java文件夹对应，我们写的clojure源文件可以放在main/clojure文件夹下，也可以放在main/resources文件夹下，因为clojure可以被编译执行，有类似脚本一样的效果，其实vert.x支持的所有语言都可以编译执行，当然你也可以先行编译之后再打包，选择权在用户，但是这里强调一下，如果将源文件放入main/resources文件夹下，打包时候，jar文件内部就将出现.clj源文件，而且在部署verticle的时候，因为clojure自身实现的问题，导致源文件不能同时编译，所以我们在部署verticle的时候，会强制串行编译clj源文件，所以这里可能会导致一定程度上的延迟，并出现warning，这个情况在其他语言的部署中也会出现，所以建议将clojure先行编译成class文件之后再打包。\n\n那要编译class文件，我们就需要maven的plugin，clojure对应的maven plugin是这个：\n\n<packaging>clojure</packaging>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.theoryinpractise</groupId>\n                <artifactId>clojure-maven-plugin</artifactId>\n                <version>${clojure.plugin.version}</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <copiedNamespaces>\n                        <copiedNamespace>!.*</copiedNamespace>\n                    </copiedNamespaces>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n而同时，我们要在打包时候支持多语言，我们需要增加shade和java自身的maven插件，所以增加之后，一个完整的maven pom.xml是这样子的：\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.sample</groupId>\n    <artifactId>test</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n        <java.version>9</java.version>\n        <clojure.version>1.9.0</clojure.version>\n        <clojure.plugin.version>1.8.1</clojure.plugin.version>\n        <junit.version>4.12</junit.version>\n        <vertx.version>3.5.1</vertx.version>\n\n        <main.class>io.vertx.core.Launcher</main.class>\n        <main.verticle>clj:com.sample.main</main.verticle>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>io.vertx</groupId>\n            <artifactId>vertx-core</artifactId>\n            <version>${vertx.version}</version>\n        </dependency>\n\n        <dependency>\n            <groupId>com.w2v4</groupId>\n            <artifactId>vertx-lang-clojure</artifactId>\n            <version>${vertx.version}</version>\n        </dependency>\n    </dependencies>\n\n    <packaging>clojure</packaging>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.theoryinpractise</groupId>\n                <artifactId>clojure-maven-plugin</artifactId>\n                <version>${clojure.plugin.version}</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <copiedNamespaces>\n                        <copiedNamespace>!.*</copiedNamespace>\n                    </copiedNamespaces>\n                </configuration>\n            </plugin>\n\n            <!--java的编译器-->\n            <plugin>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.7.0</version>\n                <configuration>\n                    <source>${java.version}</source>\n                    <target>${java.version}</target>\n                </configuration>\n            </plugin>\n\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.1.0</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <manifestEntries>\n                                        <Main-Class>${main.class}</Main-Class>\n                                        <Main-Verticle>${main.verticle}</Main-Verticle>\n                                    </manifestEntries>\n                                </transformer>\n                                <!--多语言支持必需加入该转换器-->\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\">\n                                    <resource>META-INF/services/io.vertx.core.spi.VerticleFactory</resource>\n                                </transformer>\n\n                            </transformers>\n                            <artifactSet />\n                            <outputFile>${project.build.directory}/${project.artifactId}-${project.version}-prod.jar</outputFile>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n然后我们在src/main/clojure/com/sample目录下，添加一个main.clj文件，然后写入我们期待的hello from vert.x代码，如下：\n\n(ns com.sample.main\n  (:require [io.vertx.clojure.core.vertx :as vertx]\n            [io.vertx.clojure.core.http.http-server :as server]\n            [io.vertx.clojure.core.http.http-server-request :as request]\n            [io.vertx.clojure.core.http.http-server-response :as response]))\n\n(defn handle-request [req]\n  (let [response (request/response req)]\n    (-> response\n        (response/put-header \"content-type\" \"text/plain\")\n        (response/end \"Hello from Vert.x!\"))))\n\n(defn start [vertx]\n  (let [http-server (vertx/create-http-server vertx)]\n    (-> http-server\n        (server/request-handler (vertx/handler handle-request))\n        (server/listen 8080))))\n然后用maven执行package命令，shade插件就会生成一个test-1.0-SNAPSHOT-prod.jar文件，是一个fat jar，用java -jar命令便可执行这个fat jar，当然前提是你得安装jvm环境，本文不教你做native compiling，有兴趣自己看本专栏其他文章，然后打开浏览器，输入http://localhost:8080，就可以看到效果啦，是不是很方便呢？\n\n祝使用愉快\n\nbye\n\n一个小小的bug fixed，因为第一次release，所以华丽地遗漏了vertx-lang-clojure-parent的pom.xml，在maven的依赖下，这没有问题，但是在gradle的解析中，这个环节不可或缺，少了vertx-lang-clojure-parent的话会导致依赖的jar对应的pom.xml解析失败，所以临时做了一个小补丁release上去，所以建议3.5.x版本使用3.5.1.1，而不是3.5.1 ^_^"),
    Article("8", "关于Vert.x的冷知识", "圆胖肿", "之前回答过关于Java的冷知识：圆胖肿：java有哪些冷知识?\n\n以下是Vert.x相关的冷知识：\n\nVert.x最早叫做Node.x，从名字上可以看出来，是作者从Node.js启发之后的产物，本意是实现一个JVM上的多线程Node.js\n为了避免版权问题，所以改成Vert.x，念做Vertex，在图论中，vertex和node是同义词，都表示节点，Vertex (graph theory)\nVert.x是一个帝国理工的校友Tim Fox在VMWare做message总线时候的开源项目，后来跳槽到红帽之后，就把这个项目带到了红帽，然后VMWare开始耍流氓，claim版权，于是各方妥协，将Vert.x交给了Eclipse foundation，然后也是Eclipse第一个将源代码放在github上的开源项目\nVert.x是一个Actor model的实现，但是又不局限于该模型，而进一步发展了该模型，真正Actor对应的是Verticle里面的Handler\n前面说到Vert.x是Tim Fox跑到红帽后去的开源项目，所以Vert.x的作者群，主要由红帽发工资，同时跟Netty的几个人关系密切，比如现在主要维护Netty的normanmaurer (Norman Maurer)，在访问Facebook的时候，就曾介绍过他们在Apple使用Vert.x的情况，所以我们在用Vert.x的过程中也经常会遇到Netty的bugs……\nNorman访问facebook时候的视频：https://www.youtube.com/watch?v=_GRIyCMNGGI\nNorman这个名字一看就像是德国人的名字，Netty的作者Trustin Lee是南韩人，延世大学的校友\nVert.x是多语言支持的（Polyglot），当前支持Java, Javascript, Groovy, Ruby, Ceylon, Scala, Kotlin and in future Clojure, Haskell(eta)\n这些语言里面，JS, Groovy & Ruby是脚本，起名都比较直观，Groovy就是一个简单正面的形容词，Ruby就是红宝石，没有什么特殊的，但是JRuby的符号是一个小鸟……\n说起JRuby就说到红帽有一个ProjectOdd项目组，这个项目组顾名思义，就搞一些奇奇怪怪的东西，比如JRuby，Tim Fox就曾经是这个项目组的一员，所以Vert.x也曾经是这个项目组的一员\nJRuby背后另外一个搞主的是东京大学，嗯，希望将来有一天北大等教育机构能够接管vertx-lang-clojure\n跟Java是印尼的一个小岛名一样，Kotlin也是圣彼得堡旁边的一个小岛，类似的还有Ceylon，是斯里兰卡的一个小岛，盛产茶和咖啡\nScala的意思是意大利语的梯子，希望通过这个梯子让开发人员从Java爬到fp+oop\nScala的语言很符合德国人的性格，严谨复杂，Ruby也比较能反映出日本人的性格，也比较复杂，对人的要求比较高，相比之下Java和Python就要简单很多\nvertx-lang-scala的维护者目前在德国，住在慕尼黑，某挨踢公司高级consultant，精力充沛，几乎把Vert.x除了core以外其他的模块用Scala整个包了一遍\nvertx-lang-kotlin的主要贡献者住在圣彼得堡，Haskell在JVM上的方言eta的作者在纽约\neta已经申请gsoc2018了，项目导师列表都出来了，对Haskell和Vert.x有兴趣的在校生，可以开始关注了，报名应该在春节后就开始了，详细见：ETA GSoC 2018\nClojure的符号是中国的太极，一个蓝色和绿色的太极符号，包裹着一个希腊字母lambda\nHaskell是人的名字，一个出生在麻省的数学家的名字，麻省离纽约也不远，都是新英格兰，新英格兰上去就是加拿大的新法兰西，当年戴高乐访问新法兰西，振臂一呼，独立的魁北克万岁……\neta gsoc 2018有一个导师住在澳洲的塔斯马尼亚，很多国家都有这种旅游胜地的小岛，比如夏威夷，科西嘉，济州，冲绳，塔斯马尼亚，台湾，而且不少都有分裂主义倾向\nNetty作者Trustin Lee在line，Tim Fox最新一份工作在伦敦的facebook，这个科技树上不少重要人类在搞社交\nVert.x的几个重要维护人员，目前以法国人居多，看linkedin，不少是法兰西大学校的毕业生，法兰西的教育制度很特殊，分为grande ecole和universite，可以简单认为前者就是法国的985，拿破仑定的规则，拿破仑对于法兰西的贡献，并不是他打了多少胜利的战斗；而是今天法兰西的很多制度，比如法律，比如教育，都是拿破仑定的，沿用至今\n“我一生四十次战争胜利的光荣，被滑铁卢一战就抹去了，但我有一件功绩是永垂不朽的，这就是我的法典。”\n说到秩序，嗯，Vert.x上语言的alignment：\n\n封装代表着秩序，用的人越多越evil\nbye"),
    Article("9", "小论学习的目的，比如怎样学计算机语言", "圆胖肿", "经常会遇到初学者，问，该怎么学这个学那个，比如怎样学java，这是遇到最多的问题\n\n其实学一门计算机语言，本质上跟学英语，没有太大的差别，比学英语还简单一点\n\n学英语的时候，千万千万，不要急着去被背单词，很多人学英语，就是跟着老师，一遍又一遍念课文，然后回家，一遍又一遍地把课后那些单词背下来，这样做效果非常差，事倍功半，我也曾经这样学过英语，效果显然是不好的，每次考试，都在及格线边缘挣扎，但是我觉得，这不对啊，为啥会这样？后来我的老师告诉我，因为我学习英语的目的搞错了\n\n学英语的目的，是为了交流，语法，单词，这都是为了交流服务的，所以学英语的时候，应该主动地编织自己的技能树，从最简单的，我想用英语跟人打招呼应该怎么说，然后进一步，我想表达我要做什么，该怎么说，以此类推，遇到不会的障碍，想办法克服它，因为思考过，就不容易忘记，而且要用的时候，往往就能找得到表达方式，用这种方式，就用了不到半年左右时间，英语突飞猛进，最后雅思overall 7，阅读8.5，没有拿到9分表示很不爽，轻松过线\n\n学计算机语言也是一样的，我们为什么要学java？理由呢？好找工作不是一个很好的学习理由，应该看一看，java为什么会在这么多语言中survive下来，历史上有过无数的计算机语言，但是最终存活下来的，屈指可数，就那么几个，翻来覆去都很容易看懂，那我们不妨想想为什么会这样？\n\n其实编程的目的无非三个：\n\n让机器能够执行我们的命令，而且执行得越快越好\n让别人看懂我们的代码，这个在公司里面意义特别大，协作是必需的\n让自己能够用比较少的劳动来实现目的，说白了就是让自己懒\n说到这里，就能回答我们为什么要学习java了，因为java协作最方便，所以java里面各种规则，都是为了让别人看懂我们的代码用的，理解了这个，我们再去看一些细节，就事半功倍了，所以当其他语言claim自己能比java少写代码或者是有更多语法糖的时候，这未必就是一件好事，java应该通过ide等工具自动生成代码来解决啰嗦的问题，而不是通过简写或者是不写，因为我们要让别人看懂我们的代码，这是我们的目的，但是学完了java是不是就不学了？其他还有那么多语言呢，肿么办？当然要多搞搞，不能受限于java，一般局限在一个或者几个计算机语言中的程序员会特别偏执，因为他不会其他的语言，就怕你也会，就怕你用了他看不懂的计算机语言，而且不允许你说这些语言的不足，否则如丧考妣\n\n好了，那该如何学习其他语言？或者是所有语言？那我们知道，编程语言有一个东西叫做paradigm，编程范式，计算机语言基本上是根据编程范式来区分的，同一种编程范式的计算机语言，会被归为一类，那编程范式也有很多种，那我们如果从以上三个目的出发，先看看哪种编程范式最适合这三个目的？\n\n可以看到，大概三种编程范式会脱颖而出，分别对应以上三种目标，分别是过程式编程（pp），面向对象编程（oop）和函数式编程（fp）\n\npp对机器最为友好，机器执行pp一条一条解释或者编译执行就行了，所以脚本还有硬件相关的领域用pp比较多，几乎所有的脚本都是pp，而同样是编译后的代码，oop和fp的执行效率往往不如pp，所以如果执行速度真的那么重要，一般不得不用pp\noop对阅读最为友好，java最大的卖点就是可读性超强，在任何时候，任何人写的java代码，只要你愿意，是能看懂的，pp和fp写出来的东西，别人未必看得懂\nfp对懒惰最为友好，fp为了让你懒，不惜用上各种符号和语法糖来简化你的思维负担，让你最快实现你的目的，论写得快，fp从来都是最快的，编程比赛，第一名一般都是lisp或者haskell，同样算法，用其他语言实现起来，就是不如fp写得快，fp几乎是把人的思维直接翻译成代码，其他p往往需要一次转换\n其他还有很多p，但是从目的出发，这三个p各对应一个目标，所以比较适合用来对比和作为判断标准，fp之后其实就已经非常接近对人语言的翻译了，再做一点封装应该就可以用来搞nlp了，这就是为什么lisp经常被用在ai领域的原因\n\n日常工作中，这三者往往需要权衡，任何一个领域失败了，都会让你或者是你的系统完蛋：如果你的系统执行起来非常慢，那客户体验就糟糕得不行，就没人用了；如果你的代码，别人完全看不懂，那会出现软件工程上的经典危机，你的项目最终会亡于维护成本过高；如果你开发代码的速度很慢，那我估计你的考核也不会太好，尤其是现在这种快节奏的社会，搞不好就被开了\n\n那既然我们知道了，这三种p是我们要选择的范式，那再将主流的编程语言，放入这三个范式中去，就显得自然而然了，就得到了这么一个生态链条，这个生态链条是一个深度链条，从下往上封装：\n\n汇编 -> c -> c++ -> java -> kotlin -> scala -> clojure -> haskell\n\n这个演化的过程，就是从pp -> oop -> fp的一个过程\n\n汇编是指令集，这个可以忽略，c就是pp，c++就是pp+oop，java就是oop，kotlin就是oop+少量的fp，scala是oop+fp，clojure是少量oop+fp，haskell就是fp\n\n如果你觉得繁琐，可以简化一下：\n\nc -> c++ -> java -> scala -> haskell\n\npp -> pp+oop -> oop -> oop+fp -> fp\n\n当然这个链条还不完整，很多还在演化过程中，但是从汇编到scala基本上已经成型了\n\n后者一般依赖于前者提供的环境，比如c用来做os，c++用来做单机的软件，比如jvm，db，browser，用来给上层提供环境，java用来做vert.x，提供其他语言的环境，后面的不是那么绝对，但是可以看到，scala正在给haskell提供运行环境，这就是http://eta-lang.org\n\n我听说，英国的一些本科的cs，已经在大一，就要求学生学习c, java和haskell三门语言，当我们理解了这些语言对应的p之后，再去看这个课程的选择，就会觉得特别合理，因为这样学生可以从大一开始就从不同的角度去理解编程到底是怎么一回事，就不会陷入某一种p甚至是某一个特定语言的狂热当中去，会从多个维度来看编程是肿么一回事\n\n那如果我们把一些常用的功能进一步封装起来，比如跨平台，gc这些，那么我们就可以得到一个完整的vert.x上的生态链条，这个生态链条则相对平面一点，区别于前面的深度链条，是一个广度链条：\n\npp -> oop -> fp\n\njavascript -> ruby -> groovy -> java -> ceylon -> kotlin -> scala -> clojure -> haskell\n\nclojure和haskell目前都还在往vert.x上搬迁中，这个过程还在进行中，但是基本上如此\n\n愿意的话，可以找找latte在什么位置^_^\n\n那这个时候就问了，如果我们要学会这9种甚至10种语言，怎么办？\n\n这个时候不能陷入语法的细节陷阱中去，否则累死了，要从paradigm上理解这些语言的差异，然后再通过对比语法来记忆，java是一个很好的开始，因为java最啰嗦，但是java的细节最丰富，最容易看懂，java为代表的oop就像是第三人称的描述性语言，像一部小说一样完整，通俗易懂，这里也有一个很有趣的对比，就是三种p对应了三种人称，你我他：\n\npp就是我，第一人称，我怎么做，每一步其实都可以翻译成独立的一套指令，对机器最为友好，机器最喜欢这种范式了，人怎么做机器就怎么做，所以这是指令式编程\noop就是第三人称，他，他怎么做，oop需要先找到主语，然后才是谓语动词，java里面所有的方法都要被放在一个具体的class里面，用的时候，都要先找到这个主语，也就是class/object，名词，然后才能用这个名词的动作\nfp就是第二人称，你，你去做，fp讲究把代码全部封装成函数，函数就是动词，一个纯粹只有动词的语句就是祈使句，就是命令句式，这种句式一般是很不礼貌的，居高临下的，骂人基本上都是这种句式，所以使用这种句式的时候，请注意委婉表达，最好加上称谓否则很容易翻脸，很多国人初到国外时候，外语不太好，操起动词就说\n所以fp宣称自己是命令式编程，而pp和oop是指令式编程，指令式最典型的就是pp了，oop介于两者之间，但是oop一般不claim自己是指令式还是命令式，oop最大特点是封装，虽然fp也封装，但是oop的封装是封装成对象，就特别容易理解\n\n这里补充一下命令式和指令式两个定义，我见到的版本，把人的命令，解释成命令式，而计算机汇编那种，叫做指令，所以非fp的是指令式编程，而fp是命令式编程，你可以理解成人更容易理解命令，而不是指令，机器执行指令，然后其他地方，似乎命令式叫做声明式，而指令式叫做命令式，这种翻译不同，值得留意，文中我用的是命令式&指令式，而非声明式&命令式，命令/声明式的英语是declarative，指令/命令式是imperative\n而当我们看懂了这些p有些区别之后，再去了解这些p是怎样编程的，pp比较简单，跟oop的区别仅仅在于，它不封装，或者说它不强制封装，但是fp各种幺蛾子就多一点，比如要immutable，要pure function，这个时候就需要针对这些概念逐个攻克，等这些概念都熟悉了之后，再去看细节，看语法，比如lisp/clojure喜欢有一大堆的括号，这些细节问题其实都可以通过ide等方式予以解决，这样就有的放矢，有了理论的指导，再去看那些语法细节，那就是阅读文档和记忆而已了嘛，简单很多\n\n当然这里有一步，就是要理解这些概念，那怎么理解好呢？我觉得哈，比较好的方式，就是从oop+fp的模型入手，在实践中掌握和熟悉这些概念，计算机语言，犹如英语，英语不张口说，不用，很容易就忘记，一样的，计算机语言还是要写，要在实践中去使用它，才不容易忘记，那pure fp的环境对初学者并不友好，那肿么办呢？很简单嘛，我们找oop+fp的环境，那最典型的oop+fp的环境就是actor model啦，而且我们希望找到一个polyglot的环境，让我们有动手的机会，那目前为止，actor model+polyglot的环境做得最好的，显然是vert.x啦，所以如果你学完了java之后，觉得，诶，要探索一下未知的领域，那vert.x是一个非常好的demo以及出发点，在使用vert.x的过程中，你肯定会接触到各种fp的概念，比如immutable，eventbus上发消息就要求immutable，因为reactive programming本身就是fp化的编程模型，vert.x一开始就是按照这个模型制造出来的，这里说一下，协程并不是reactive programming，而是proactive programming，因为协程会把fp/reactive的方式，扳回到oop也就是proactive的方式上去，最近看了不少文章说用了响应式编程，然后里面大谈协程也是醉了，当然这种细节留给读者在搞vert.x过程中慢慢品味了\n\n搞vert.x的每一天都沉浸在编程的欢乐之中，不写代码浑身难受，难以自拔，搞vert.x会上瘾\n\nbye"),
    Article("10", "Vert.x上的Clojure语言支持（项目已开源）", "圆胖肿", "Previous in 白木城全栈：在Vert.x上实现Clojure语言支持的探索\n\n前一篇文章探索了如何在Vert.x上实现Clojure语言包的支持，基本上做了一次可行性分析，最后发现，好像，似乎是可以的，于是我们说干就干，经过大概一周左右的各种攻坚，算是有了一个还算不错的结果^_^\n\n先说结论，子项目名称是vertx-lang-clojure，基本上跟Vert.x其他的语言包命名保持一致，已经开源在Github上，地址是：whitewoodcity/vertx-lang-clojure all issues, comments, prs, forks are welcomed.\n\n以下是整个过程的唠叨，Vert.x的语言支持在v2时代是通过人工，每一个语言一个接口一个接口实现过去，这样做的结果就是慢，不仅慢，而且效率低，维护成本高，会出现每一个语言特定的错误，每一个语言都要专门test一遍，对开发不利，所以在v3时代，项目组转入了通过使用mvel自动生成代码的做法，先通过Java将核心代码实现，然后暴露出相应的API，再通过annotation对每一个api做标记，然后通过mvel的模版功能，将这些api转换成相应语言的API，这就是vertx-codegen子项目。\n\n通过这种方式，第一批生成的是脚本，也就是面向过程（pp）也就是不需要强制封装的三个语言的api，分别是Groovy，Ruby和Javascript，因为不需要封装，做起来最快，唯一需要处理的就是把caseCamel驼峰命名法改成case_snake的命名方式，脚本多数都采用_分割的case_snake命名法；其次就是把Ceylon，Scala还有Kotlin给转换过去，这三个语言跟Java的冲突都没有那么明显，因为都是面向对象（oop）语言，在封装层面上，都要求封装成对象，至少都允许封装成对象，kt&sc还允许最高层次（top/1st level）是函数，但是这两个并不冲突，不需要对原有系统做多少改变即可实现，可专注于封装之后的API生成工作，而且这三个语言做的层次都有些不太一样，Kotlin的封装最浅，几乎用的都是Java自己的API，其次是Ceylon，通过codegen自动生成了一批Ceylon的API，Scala封装得最为深入，不仅通过codegen自动生成了相对应的API，还自己实现了一层符合Scala使用习惯的API。\n\n那我们知道，三种比较主流的编程范式（pp，oop和fp），Vert.x还缺少函数式编程（fp）的支持，于是我们去Haskell/http://eta-lang.org项目下面建议，希望作者将http://eta-lang.org也提供Vert.x的支持，经过群众们的踊跃投票，在纽约的作者将Vert.x的支持纳入了eta v0.2的计划之中，所以在不远的将来，我们有可能看到Haskell出现在Vert.x上；那函数式的两大流派，lisp&haskell，肿么能少了lisp呢？更何况在Vert.x V2的时候曾经出现了Clojure的语言支持，于是我们找到了原作者Toby，咨询了相关的问题，了解了情况之后，于是我们就琢磨，如何将Clojure搬到Vert.x上去，也算是为http://eta-lang.org探探路，算是一个练手吧。\n\n具体的可行性分析见前一篇文章，那这里说一下实现过程，首先是通过上手mvel模版以及codegen来实现代码自动生成，毕竟是开源的项目，所以官方文档很不完整，也不友好，好在经过我们不屑努力，总算搞明白了逻辑，原来是需要maven，用maven的compile命令便可自动生成代码，官方提供了一个starter项目，介绍了如何自动生成md文件，经过一番努力之后，将其成功执行，执行成功之后，就开始通过mvel的模版以及codegen提供的API，来自动生成Clojure代码，要特别感谢Clojure-Kit这个好用的插件，使得我们可以很方便滴在生成代码之后，就能看出生成的代码是否正确。\n\n官方的API也大概分为两块，class&dataobject，class主要是动作的包装，里面的API都是方法，dataobject则是名词的包装，对应的都是data object，json之类的实体，那purely fp语言，封装的层面都是方法，top/1st level一律都是方法，方法之间的对象是immutable的，以减少副作用，所以第一步先把class里面的方法转换成命名空间也就是namespace（ns）里面的方法，注意Clojure里面的ns不是Java里面的class，两回事，你可以认为ns里面的都是静态方法，但是除了Java以外，其他语言几乎没有静态这种概念，静态是Java为了purely oop而做出的一种妥协和牺牲，作为purely fp语言，则没有这个考虑，方法就是方法，不存在有静态的说法，而且方法和对象之间，没有必然的隶属关系，不像Java，每一个方法都一定要对应一个类或者是对象，先找到类和对象，才能使用相对应的方法。而且顶层几乎都是方法，ns是方法的集合，而我们需要转换的是Java的API，所以第一步就是将所有的非静态方法和静态方法都做成方法，静态方法处理相对简单，生成的ns直接对应class名称，然后静态的方法名照搬，参数照搬，因为clj没有类型声明，或者不是强制类型声明，所以类型可以不用考虑，省不少事，这点跟脚本很像。但是非静态方法，则要费点事，那就加多第一个参数，第一个参数就是对应的对象名，例如object.methodName() -> (method-name object)，同时加多构造器，只不过构造器不再是new，而是new-instance，灵感来自Class.forName().newInstance。\n\n通过这种方式生成代码，clj类型相对容易处理，但是比较麻烦的是clj的命名，clj的命名是所有语言中需要转换最多次的一个，比如脚本只需要考虑case_snake便可，而其他的语言，则多数都使用驼峰命名法，所以几乎不需要什么转换，但是clj既使用了case_snake，在文件名上，要兼容Java的文件名，否则出错，又使用了case-kebab，因为lisp的传统就是case-kebab，所以费了两天时间在这种命名的转换上……\n\n改造完成之后，下一步就是如何将其整合进Verticle的事了，因为ns文件都是方法的集合，不存在有对象这种文件，不能像oop语言一样，做一个文件，然后实例化这个文件，这不够fp，所以我们还是通过Java实现一个wrapperverticle，然后在这个Verticle内，调用ns里面的方法，完成各种函数的注册，嗯，对，就是Vert.x里面的各种handler，ns里面都是方法，Vert.x启动的时候就是将handler也就是我们写的lambda注册到各个源上去，所以我们实现了一个ClojureVerticle.java的包装类，然后通过ClojureVerticleFactory.java将服务挂到Vert.x上去，原理跟script engine类似，跟Latte作者交流时候，因为之前跟他聊过jsr223的支持，所以这次他一下就明白了，经过这两个类和META-INF里面设置之后，vertx对象就能自动识别clj的前缀和后缀啦，那用户只需要提供给ClojureFactory以ns名（以.clj结尾），ClojureFactory就会自动生成一个ClojureVerticle对象，在该对象的start方法中，就会自动寻找相对应ns文件里面的start方法，然后将其执行。\n\n但是这样做又遇到了一个问题，Clojure允许即时编译执行，其效果等同于脚本解释执行，也就是提供给Clojure环境一个.clj源文件，Clojure就能够直接将其编译并执行，不需要像Java一样预编译成.class文件，再执行，这似乎是一件好事，但是，Clojure的并发编译会出并发问题，所以系统必需先判断.clj源文件是否存在，如果存在，则加多一个锁，强迫所有的需要编译的clj文件的编译执行串行，嗯，好绕啊，那酱紫肯定是不好啦，肿么办呢？\n\n嗯，好消息是，clj还可以预编译嘛，于是找到了clj的maven plugin，将其放入，哇，该插件很好一点就是会自动寻找src/main/clojure以及src/test/clojure目录下的文件，将其编译成.class，但是坏处是会把源文件一起拷贝过去，而Clojure的runtime看到.clj结尾的源文件就兴奋，会编译执行，而不是直接执行class文件，所以我们有必要将其排除在外，所以最后的插件变成了酱紫：\n\n<packaging>clojure</packaging>\n...\n            <plugin>\n                <groupId>com.theoryinpractise</groupId>\n                <artifactId>clojure-maven-plugin</artifactId>\n                <version>${clojure.plugin.version}</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <copiedNamespaces>\n                        <copiedNamespace>!.*</copiedNamespace>\n                    </copiedNamespaces>\n                </configuration>\n            </plugin>\n关键的copiedNamespace设置就会将.clj排除在外。\n\n还遇到了codegen项目本身的一些问题，都反馈给了Vert.x官方，经过各种踩坑之后，算是有了一个不错的结果，项目所对应的jar包已经release在github上了，有兴趣的可以下载下来，然后在本地将其引入依赖，就可以像其他语言的依赖一样使用啦。\n\n后续的工作主要是将现有的ns文件做整合，做成几个大的ns文件供用户更加方便地使用，还有文档，测试等工作，算是一个长期的工作了，但是这个语言的支持，大概的骨架什么已经出来了，在这里踩个脚印，算是留念一下^_^\n\n最后截图一张，左边是clj文件，中间是其中一个刚写好的json的ns，右边是maven的菜单，Clojure的太极图标真是画得不错：\n\n\nVert.x官方主页上的Hello from Vert.x!的clj版的例子，用了箭头，但是注意clj里面的箭头跟其他语言的lambda的箭头完全两回事，clj的箭头是宏：\n\n\nHello from Vert.x!\n目前代码总量大概是14万行+，多数是系统通过模版自动生成的。\n\nsnapshot版本已经发布：Index of /repositories/snapshots/com/w2v4\n\nbye"),
  )


  private val dataPath = "/Users/leibnizhu/Desktop/Data"
  private val log = LoggerFactory.getLogger(getClass)

  test("将Article对象写入到文件") {
    val context = Vertx.vertx().getOrCreateContext()
    context.config().get.put("articlePath", dataPath)
    Constants.init(context)
    source.foreach(article => article.writeToFile(ar => {
      if (ar.succeeded()) {
        log.info(s"写入文章(ID=${article.id}, 标题=${article.title})成功")
      } else {
        log.info("写入失败:" + ar.cause().getMessage)
      }
    }))
  }

  test("从文件读取解析成Article应该跟写入的一样") {
    val context = Vertx.vertx().getOrCreateContext()
    context.config().get.put("articlePath", dataPath)
    Constants.init(context)
    CompositeFuture.all(new File(dataPath).listFiles().filter(_.getName.endsWith(".txt"))
      .map(file => {
        val future: io.vertx.scala.core.Future[Article] = io.vertx.scala.core.Future.future()
        future.setHandler(ar => {
          if (ar.succeeded()) {
            log.info("读取文件" + file.getName + "成功")
            val article = ar.result()
            log.info(article.equals(source.filter(_.id.equals(article.id)).head).toString)
          } else {
            log.info("读取文件" + file.getName + "失败")
          }
        })
        Article.fromFile(file, future.completer())
        future
      }
    ).toBuffer)
  }
}
